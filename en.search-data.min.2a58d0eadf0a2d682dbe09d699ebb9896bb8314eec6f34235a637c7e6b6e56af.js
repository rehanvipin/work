"use strict";(function(){const t={cache:!0};t.doc={id:"id",field:["title","content"],store:["title","href","section"]};const e=FlexSearch.create("balance",t);window.bookSearchIndex=e,e.add({id:0,href:"/angular/",title:"Angular",section:"Introduction",content:` Angular, the fancy web framework # Angular lets you make dynamic web apps easily. This was written when Angular 14 came out.
Base Knowledge # I know nothing about Angular. I know a bare minimum of HTML, CSS, and JS. Let&rsquo;s see how this goes.
Course stuff # I&rsquo;m following along The Angular Fundamentals course on Pluralsight. The authors have nice practice exercises available on their website. Code for the course is available on GitHub.
This Crash Course by Traversy Media is also very good.
Finally, The Angular docs are very good.
What if you want to go even further and understand exactly what is happening? E.g., stuff about zones and change detection. Check out the articles at Angular in Depth
Just to note, the content I put up here is whatever I understood out of the courses and many other sources off the internet. I haven&rsquo;t and I won&rsquo;t rip content off sources. I write this stuff on my own, but when it comes to things like specs and such, they do need to be put in word for word.
Fun stuff # Some cool things I learnt along the way:
When you run ng new coolstuff, it generates a lot of files. The file structure is explained here. The JSON pipe is useful when you want to display an object in a template. Use it like this: {{ objkt | json }} To see what happens when you run an ng command, suffix it with --dry-run There&rsquo;s the options to convert your components into web components. This means they can be framework agnostic. They&rsquo;re still working on making the output Angular free at the time of writing this post. Web components have good browser support. `}),e.add({id:1,href:"/misc/d3/",title:"D3",section:"Fun Stuff",content:` Data Driven Docs? # It&rsquo;s a powerful library with a bit of a learning curve.
There a heck lot of things it can do. Nice confusion. These might be some good resources:
An updated D3 tutorial (This was the best!) Official tutorial (It can take some time to get used to observableHQ&rsquo;s notebooks) Huge collection of tutorials https://wattenberger.com/blog/d3#intro [SUGGESTION]: Do the d3indepth tutorial first and practise a bit by trying to make your own visualizations. The other resources can be useful when you&rsquo;re stuck.
SVGs # This is one popular way to display graphics onto a webpage. It&rsquo;s the one that most D3 visualizations use.
There are already good resources available online. Check them out:
Kevin Powell&rsquo;s guides on YouTube Understanding SVG by Sara Soueidan - this is a series of 3 articles, at the end of this one there&rsquo;s a link to the next one. They&rsquo;re pretty deep and help you understand what&rsquo;s really going on. Selection # One feature of d3 is the ability to select and modify the DOM.
Core to this are select and selectAll which take in an HTML Element or a CSS selector. Both return a Selection object.
API for selecting and selections.
Properties # The object has a few functions, each of which return a Selection object (that means chaining is possible)
Function Params Description style &lsquo;css-prop&rsquo;, value Sets a css property attr &lsquo;html-attr&rsquo;, value Sets an attribute on the HTML element classed &lsquo;classname&rsquo;, value Removes or adds class depending on value property &lsquo;html-prop&rsquo;, value Sets HTML attributes which can&rsquo;t be set by &lsquo;attr&rsquo;. E.g. checked on a checkbox text value Sets the text within a HTML element html value Sets HTML within the selected element select CSS selector Can be used to select child elements value can be an actual value or a function. The function takes in two params:
d the datum, which is the data value corresponding to the index i the index of the element among other elements in the Selection. Its possible to add an event to the Selection with the on property like so:
d3.select(&#39;rect&#39;) .on(&#39;hover&#39;, function(event, datum) { // can be any DOM event // \`this\` inside this function refers to the HTMLElement // to get a d3 Selction from it you must do d3.select(this) }); Because of the way this works inside arrow functions, don&rsquo;t use arrow functions for the callback of on if you want to use this.
When it comes to D3, it might just be a good idea to use function for most use cases.
Insertion / Deletion # Its possible to insert / remove DOM elements with D3. The functions are:
.append('element-tag') creates the specified element as the last child of the selection .insert('element-tag', 'css-selector') same as append but it places this element before the CSS selector specified .remove removes the element(s) in the Selection from the DOM Processing # A Selection can be processed in these ways:
.each(function(d, i){} calls the function for each element. .call(function(theSelection){}) calls the function once for the selection. It passes the selection object as an argument. .filter(function(d, i){}) calls the function for each element. It returns a new selection that only contains elements that returned true in the filter function. .sort(function(datumA, datumB){}) sorts the elements in the DOM with the comparator function. Data Joins # Modifying visual elements according to data in a declarative manner. It usually works like this:
Create a Selection of the parent element which will hold the visual elements. Create an empty Selection with .selectAll('element-to-join'). Create a Selection with data by calling the data method on it with an array as the argument. On the latest selection call .join('element-to-insert') Article to help with understanding joins. Another article. This one&rsquo;s about modern joins
Selection Join # This join automatically appends and removes elements but also provides the ability for fine control. A sample:
d3.select(&#39;g&#39;) .selectAll(&#39;circle&#39;) .data(array) .join(&#39;circle&#39;) .attr(&#39;fill&#39;, &#39;blue&#39;); To control what happens to enter, update and exit elements, pass functions as args to it like so:
selexon.join( function(enterSelection){}, function(updateSelection){}, function(exitSelection){} ) Keys # It&rsquo;s possible to make sure that DOM elements are exactly matched with the same data even if the elements are moved around. This is possible via a key function which assigns keys to DOM elements based on the data they get like so:
xyz.data(array, function(d){ /* return unique id */ }) Enter, Exit &amp; Update # This picture from https://bost.ocks.org/mike/join/ is a good explanation: This way of joining is fine-grained but it can be tedious. It&rsquo;s mainly used for transitions. A more concise way is using the new selection join (D3 v5+).
An example. Given a DOM like:
&lt;svg&gt; &lt;g&gt; &lt;circle&gt;&lt;/circle&gt; &lt;circle&gt;&lt;/circle&gt; &lt;/g&gt; &lt;/svg&gt; Circles can be selected like so:
let data = [10, 8, 15]; let circs = d3.select(&#39;g&#39;).selectAll(&#39;circle&#39;); Existing elements can be joined with data like so:
circs.data(data).attr(&#39;r&#39;, d =&gt; 2*d); New elements can be created for extra datum:
circs.data(data).enter().append(&#39;circle&#39;) Elements which don&rsquo;t have a datum:
circs.data(data).exit() Scales # Scales provide a way to map values from a domain to a range. They can be continuous or discrete. (There&rsquo;s no scale for D to C though).
Usually the domain consits of data values and the range consists of visual properties (height, position, color, etc.)
C to C # There are many scales here: Linear, Quadratic, Log, Exponential, etc. An example:
let scale = d3.scaleLog(); scale.domain([1, 100]); scale.range([0, 1]); let scaledVal = scale(50); For fancy colors there&rsquo;s also d3.scaleSequential() which instead of a range, has an interpolator. E.g. scale.interpolate(d3.interpolateRainbow)
C to D # A straightforward function is .scaleQuantize() which splits the domain into equal divisons among the range. It also clamps inputs into the domain.
To split the domain into specific groups .scaleThreshold() can be used. .domain([/* array of n values */]) will create n+1 groups (&lt;arr[0], &gt;arr[0] &amp; arr[1]&lt;, &hellip; arr[n-1]&lt;). They are matched one-one with the range items. If there aren&rsquo;t enough elements in the range, the groups are allocated to the last item.
D to D # The simplest way to do this is .scaleOrdinal() where the elements in domain are allocated on range element. If there aren&rsquo;t enough range elements the array repeats. If the value to be scaled doesn&rsquo;t exist in the domain, the scale will automatically add it. To prevent it from being added, specify a default value to be returned for unknown elements with scale.unknown(value)
There are other functions too like .scaleBand() and .scalePoint().
Shapes &amp; Lines # D3 has generator functions to generate paths that represent line graphs, pie charts, curves, and more. This works using the &lt;path&gt; SVG tag and setting its d (data) attribute to a special strings returned by the functions which contain instructions on how to draw the required shapes.
Common generators # Name Description Configurable params line Simple line graph x, y for each point in the line radialLine Like a line graph but instead of going left to right, it goes around a center angle, radius for each point around the center area Area between two lines (need not be straight lines) x, y0 for top line, and y1 for bottom radialArea Like how radialLine is to line angle, innerRadius, and outerRadius The configurable params can either be a function that takes in one value and returns a value, or it can be a value. E.g. lineGenerator.x(909) and lineGenerator.x(d =&gt; d+10) both work.
Example usage:
let inputData = [/* complex objects */] let lineGen = d3.line(); lineGen.x(arrayVal =&gt; arrayVal.prop1 + 10) lineGen.y(arrayVal =&gt; arrayVal.prop2 - 5) let pathData = lineGen(inputData); d3.select(&#39;path&#39;).attr(&#39;d&#39;, pathData) Instead of passing an array of objects and configuring each param, the user can also just feed an array of arrays to the generator.
To handle invalid data in the array, the user can set .defined(datum =&gt; {}) on the generator. D3 will skip the element if the callback function returns false for it.
Interpolation of the points can be changed by calling .curve(someCoolCurveGen) on the generator. Check out some popular curves in the docs.
Axes # These help give the user a scale of the data. An axis can be created in a container like &lt;g&gt;. Select the container. Create an axis with .axis[Left|Right|Top|Bottom](scale).
The scale&rsquo;s domain determines the ticks on the graph and the range helps determine its length. The axis can then be passed to the container Selection like so: gSel.call(axis). That&rsquo;s it!
It isn&rsquo;t limited to uniform ticks. Different scales like .scaleSqrt() can be used with axes. To make the axis look better, the domain can be rounded to &ldquo;nice&rdquo; values like so: d3.scaleLinear().domain([11, 39]).nice() will change to domain to (10, 40).
The number of ticks can be changed by axis.ticks(n) or even set tick values like axis.tickValues([a, b, c, d]). The label of each tick can be formatted with something like .tickFormat(d =&gt; &quot;-&quot;+d)
Hierarchies # There are multiple layouts here such as tree, cluster (just like a tree but all the leaves are on the same horizontal level), treemap, and so on. This section will focus on the tree layout.
It uses the output of d3.hierarchy, a nested object, to layout the tree. hierarchy itself needs a nested object as input or a map of maps.
hierarchy # Given an input with the format discussed above, hierarchy returns a nested object where each object (node) has the following params:
data : The item in the input data that this node is associated with. E.g. a map key and its value. children : array of references to children (not present in leaf nodes) depth height parent : reference to parent node It also has methods like:
descendants : Returns an array of all its descendants ancestors : Returns an array of all its ancestors links : Returns an array of all links under this subtree. A link looks like { source: reference to source node object, target: reference to target node object } Tree Layout # A tree layout function can be created like so: let funk = d3.tree(). The size this element will take in the DOM can be set like so: funk.size([ht, wd]). The layout can then be applied to the hierarchy object like so: funk(hierarchyOutput).
The tree&rsquo;s size need not be set explicitly, instead, a combination of .nodeSize([ht, wd]) which sets the minimum space a node must be alloted, and .separation((a, b) =&gt; 1) which sets the the space between two nodes in terms of nodeSize (e.g. 3 means a and b will be separated by the space that 3 nodes would occupy)
Applying a layout means it will add extra properties (display properties e.g. x and y locations) to each node in the hierarchy.
Now that the object has display properties, it can be used to create DOM nodes and position them.
Nodes # Use the rootNode.descendants() array along with a join for whatever shape you like (e.g. &ldquo;circle&rdquo;).
Edges # Use the rootNode.links() array along with a join which creates lines with &ldquo;path&rdquo;.
Transitions # When data gets updated, elements might have new places, might look different, or even vanish. Without smooth transitions, the transitions looks janky and not &ldquo;natural&rdquo;.
To have a transition just call transition() on the Selection before calling any attr methods for which you want a transition.
Could be position (e.g. &lsquo;x&rsquo;, &lsquo;cx&rsquo;), color (e.g. &lsquo;fill&rsquo;), or even size (e.g. &lsquo;r&rsquo;). It creates a transition Selection which has a few more methods and it automatically creates a transition when the join runs.
A delay can be added by calling delay(durationInMilli). A duration for the transition can be set with duration(durationInMilli)
Instead of setting a constant duration both the functions can take a callback function which can set determine the value according to some factor e.g. (d, i) =&gt; i*1000
Calling transition() a second time in the Selection chain will cause the second one to play out after the first one has finished.
To put separate transitions for enter, exit, and update elements, use separate functions for the join and apply transition() within them where required. E.g.
coolSelection.join( function(enterSelect) { enterSelect.transition() .attr(&#39;r&#39;, d =&gt; d+10) }, function(updateSelect) { updateSelect.transition() .attr(&#39;fill&#39;, &#39;green&#39;) }, function(exitSelect) { exitSelect.transition() .remove() } ) There are other topics too but this should be enough to get started.
`}),e.add({id:2,href:"/angular/overview/",title:"Overview",section:"Angular",content:` An overview (and miscellaneous stuff) # Angular is a platform, apparently, that includes a framework, some libraries, and developer tools to work with all of that. For most purposes, it&rsquo;s called a front-end web development framework.
The bootstrap process # The first file that is run is main.ts (as defined in angular.json That&rsquo;s a very useful file). It bootstraps a module, app/module.ts by default. It bootstraps the root component, app/app.component.ts by default. The root component is placed in app/index.html which is what is rendered. Modules and libraries # Only the root NgModule should have a bootstrap property in its decorator. The bootstrap property sets the root component for the app. Libraries are plain JS modules which can have angular modules. A component / directive / pipe can be declared in only one NgModule To use stuff that other module provide, you import that NgModule in this NgModule When you list services in the providers array, they are available app wide. It&rsquo;s possible to have multiple entry point components in the bootstrap array. File structure of workspace # Deployment ðŸŽˆ # This is done with the ng build command which:
Minifies code (removes whitespaces and renames variables) Bundling (merges many JS file into a single JS file) so fewer requests are made Tree shaking (the production app doesn&rsquo;t have code that is never used). It&rsquo;s a little different from dead code elimination. Angular has an Ahead Of Time (AOT) compiler that converts the HTML of templates into JS code that manupilates the DOM. It can help catch template errors, reduce the output size, and make rendering on the browser faster.
How is the compiler helpful? It converts all components into JS functions which creates the component view / updates it. These are called template factory functions.
The runtime app just needs to call these functions. It does not have to deal with parsing the raw templates etc.
By default, running ng build will generate a &ldquo;development&rdquo; build which can still be deployed but isn&rsquo;t as optimized as it could be. To run it in &ldquo;production&rdquo; mode use ng build --prod which reduces the number of requests and file sizes.
Deployment just involves copying the directory within &ldquo;dist&rdquo; to the web server!
Zones # Angular used to use a zone.js library which would patch Web APIs of the browser and call Angular&rsquo;s change detection when there were any asynchronous actions or user interactions. This abstracted change detection but could lead to too many calls to change detection, or sometimes, too few if some fresh browser API is not yet patched by the library.
Nowadays, it is possible to remove zone.js entirely and get change-detection via other means. One of the old ways was via the ChangeDetectionRef and it&rsquo;s detectChanges function.
Change Detection # After Angular has created all the component views, change detection for any component can be called at some point (e.g., by zonejs as mentioned above).
Why? It ensures that the view and model are up-to-date. All data in a component is synced with the rendered view and with child components.
The nice part about this is that developers only (mostly) need to be worried about updating the model. This feature is also called &ldquo;rendering&rdquo; loosely.
How? At a high-level, it can look like this:
update bound properties passed to a child, then call the lifecycle hooks for that child. do this for every child directive. update bound properties in the current component&rsquo;s view. call content-level lifecycle hooks - AfterContentChecked on all children components. AfterContentInit on the first time run change detection for children. it will perform a pre-validation to see whether child component is &ldquo;dirty&rdquo; or &ldquo;always check&rdquo;, and will early exit the function in the child if possible (not doing unncessary things like template updates). call view-level lifecycle hooks - AfterViewChecked on all children components and self. AfterViewInit on the first time Angular always maintains the list of bound properties which are used by children / in its own DOM. This is in a separate store (called LView) from the object properties of the instantiated component JS object. It can help determine if values have changed. The LView data is updated in the first and second step of the function for children and self respectively.
Angular has a principle of uni-directional dataflow from parent to child components, for performance benefits.
To enforce that, one of the things it does is run a check after all the above operations are done in the Change Detection function. checkNoChanges. It compares the LView data with the instantiated object properties to make sure that view &amp; model are in-sync after Change Detection.
If they are not, Angular throws an error : ExpressionChangedAfterItHasBeenChecked to warn users that the data displayed on the page might be wrong.
If there was no expectation of uni-directional dataflow, change detection would need to run an unknown number of times before the view and model are synced.
Angular is really a tree of Views, with each one having an LView data structure. Components are compiled into functions to create views, with each view having access to an object instantiated of the Component&rsquo;s class. Each of view trees start at a rootViewRef. Bootstrapping an app creates one of these. Things like modals end up in another view tree. They are all managed by one ApplicationRef. Change Detection is independent for them.
The starting element of a root view would be a HostView which attaches Angular views to regular DOM elements such as document, or body or wherever.
HostView is not an element though. The element would be of the Angular Component e.g., AppComponent.
`}),e.add({id:3,href:"/java/intro/",title:"Setup",section:"Java",content:` Introduction &amp; Dev Setup # What is the Java platform? # The Java compiler, which defines what the Java language is and converts it to bytecode. Also a bunch of other tools which can help in development e.g., tools to inspect / decompile files. The Java Virtual Machine which executes the bytecode on the computer. This along with the classes required to run the program (i.e., standard libraries) is called the Java Runtime Environment. These two together make up the Java Development Kit, which is required to write and execute Java programs.
If you only want to run programs, the JRE is enough. Note that the Java standard library is platform independent. If you want to run Java code on a platform, all it requires is the JVM for that platform. This means that alternative languages like Scala and Kotlin can make use of these libraries and similarly Java code can use compiled bytecode generated from other languages.
Wait &hellip; what the heck is Java SE (Standard Edition) now?
Java SE is a specification for the JDK and a bunch of extra libraries (e.g., Java FX).
There&rsquo;s also Java ME (Mobile Edition) to run on low capability hardware.
There&rsquo;s also Java Card for &hellip; smart cards and stuff.
There was a Java EE but it&rsquo;s not maintained anymore, it&rsquo;s now become Jakarta EE (not sure what that is).
OpenJDK is an open-source implementation of the Java SE spec. Only source code though. It doesn&rsquo;t have any binaries or installers for the JDK.
Who builds the binaries / installers? People like Azul systems, Oracle, Microsoft, Adoptium etc. They might modify the source code a bit.
Setting up dev environment # Firstly, you will need a JDK. You can download a build of the OpenJDK. It&rsquo;s a zip file containing these items: bin conf include jmods legal lib release. Unzip the contents in some location e.g., /home/user/jdk. This will be the value of JAVA_HOME variable Add the location of the binaries to your PATH, you can add $JAVA_HOME/bin Where is the compiler and the JVM? In the bin directory.
Where is the standard library? In the jmods directory. There are a bunch of .jmod files.
Packaging the output # Turns out, the process is similar to creating tar files. It actually follow the .zip format though. JAR files on decompression contain .class files arranged in the required structure. They also have a META-INF/MANIFEST.MF file which contains metadata about the JAR and tells where the main class is that has to be run. This will be specified in a key-value pair like so: Main-Class: net.java.bingo.Main.
You can specify a custom manifest file that it will use to create the actual manifest file. To do that, just add a m option to the command e.g., jar cmf MY-FAV-MANIFEST.MF Output.jar src/.
Why is the standard library a bunch of .jmod files? # This change happened in Java 9 to make a space optimize JRE. They are very similar to .jar files, they can additionally have native code and other stuff that don&rsquo;t go in JAR files.
They are to be used in the &ldquo;link&rdquo; phase between the compile and run phase. This is where a set of modules can be assembled and optimized into a custom run-time image. As per the JPE
The JVM # What&rsquo;s the default VM that Java uses? It&rsquo;s called the Hotspot VM. The Hotspot project has also developed runtime libraries.
The Java VM could be seen as being made of:
Class loaders # Loads classes as required, dynamically, to the JVM.
Interpreter # This executes bytcode line by line.
JIT Compiler # If a method is being called frequently, it is compiled to machine code in a separate thread. Once that&rsquo;s done, the next invocation would be through machine code directly. Meaning it will be faster.
There&rsquo;s also the garbage collector and platform specific libraries required for execution. For cases where you need to access native methods through Java, there&rsquo;s also the Java Native Interface.
Passing CLI properties to the JVM # There are some standard options e.g., -cp for classpath, -agentlib, -dsa etc. How do you define system properties for your program? Through -Dprop-name=prop-value . There are some non-standard options which can be set with -Xprop-name=prop-value . Some advanced options can be set with -XX
I should probably create a separate section about exploring the JVM.
The JRE # What are the classes / properties files required to run java programs? Note that the location of these classes have changed with Java 9. Relevant JEP explaining the new locations. There&rsquo;s no more an rt.jar or tools.jar (which were known as bootstrap classes), they have been moved to modules in the lib directory. The configuration files are at $JAVA_HOME/conf.
Now, it&rsquo;s also possible to create your own JRE which contains the modules only required to run your app. This can be done via jlink and helps in making Java apps which ship with their own JRE and don&rsquo;t have any requirements on the users to have a full JRE pre-installed.
How can you do so? Adoptium has a small guide.
The development tools # There are a bunch of extra tools like disassemblers, debuggers, security tools, RPC tools and monitoring tools (e.g., jps, jconsole etc) which come with the JDK. A small list of them can be found here : Baeldung.
`}),e.add({id:4,href:"/spring-boot/framework/",title:"Spring Framework",section:"Spring Boot",content:` Spring Framework # What? Why would you use it? # It is a dependency injection framework that helps you simplify your code and make it more testable. It started as an alternative to Java 2 EE and has now grown beyond it. It even includes a web framework (Web MVC) within it. Baked in with best practices so you can focus on the business problem.
It encourages you to use interfaces and helps minimize configuration code.
That should make your app more flexible to different implementations and make it easier to test.
It&rsquo;s popular as it encourages developers to write POJOs rather than Enterprise Java Beans and stuff.
Another selling point of the Spring Framework is that it provides config files instead of needing to hard-code stuff. In Spring v5 (not sure since when), almost all configurations can be done with just Java. No XML necessary. Why would you still use XML configuration? It provides a separation of concerns where wiring up dependencies can be done away from the app code.
`}),e.add({id:5,href:"/angular/components/",title:"Components",section:"Angular",content:` The real CONTENT # Fun fact: The @Component decorator actually extends @Directive decorator because components are technically directives.
Creating them # A bare component is a class, defined in a .ts file. You can create new one like this:
Create a .ts file and export a class that is decorated by Component from @angular/core. The decorator takes in an object as argument. The object has properties like selector (which is a CSS selector to find out which HTML elements this component should apply to) and template (or templateUrl). Import this class in app.module.ts and add it to declarations in the NgModule decorator of AppModule. Data binding: Accessing the component&rsquo;s properties within its template via the {{ any JS expression }} syntax.
The constructor of a component should ideally be empty, put intialization code in ngOnInit.
Communicating with a child component # When you have a child component within your component you can pass data to it via HTML attributes. The process is:
Create a property on the child component class that is prefixed by the @Input() decorator. E.g. @Input() title: string In the child component&rsquo;s tag in the parent component&rsquo;s template, pass the value like this: &lt;child-comp [title]=&quot;any JS expression&quot;&gt;&lt;/child-comp&gt; You can react to changes in any of the input properties via ngOnChanges(){} You can also set an input propert setter like so: @Input() set propname(val) {} where the function is called every time propname changes. Just like a JS setter. Communicating with the parent component # The common patern here is passing along an event to the parent component. It works like this, overall:
Create an event handler to respond to some event in the child HTML. Just a function property of the class. Like so, handleHere() {} Create an event emitter property that is decorated by Output. Like so, @Output() handledByParent = new EventEmitter() In the even handler you can call handledByParent.emit(anyVal) which will emit an event by the child component In the parent, you can create a handler for the event, like so: &lt;child-comp (handledByParent)=&quot;parentHandler($event)&gt;&lt;/child-comp&gt;. $event is a special keyword that contains the value passed to emit. You can only pass one value. parentHandler is a function property of the parent component. Styling em # You can add styles for a component (other than the global styles), in two ways:
Create an array of strings, where each one can have CSS style rules and assign that to the styles property of the decorator object of the component Add the rules in a file and create an array of strings (with file names) and assing it to styleUrls. Within the styles, if you want to refer to the element which the component is tied to (i.e., the one in the component&rsquo;s selector) use :host, e.g., :host { font-style: monospace; } CSS Encapsulation # When you add CSS styles to your component, it only matches the elements directly in the component. It does not apply to a parent or child component. This is how that works:
Angular automatically adds attributes to every element within a component. Within a component, they all have the same attribute which is unique to elements in that component. It also modifies the CSS of that component to apply only when that attribute is present.
There is a way to pass down styles to children by using a &ldquo;deep&rdquo; selector (google when needed).
Global styles are not mangled like this.
Content Projection # AKA &ldquo;How to reuse components&rdquo;. Components have &ldquo;content slots&rdquo; within them. You can reuse a component by putting different content within these slots.
If the parent template looks like:
&lt;h2&gt;Hip hop&lt;/h2&gt; &lt;somechildcomp&gt; &lt;button&gt;woop&lt;/button&gt; &lt;h3&gt;sneak&lt;/h3&gt; &lt;/somechildcomp&gt; The button and the h3 (basically all content within those tags) will be available to the child component via &lt;ng-content&gt;&lt;/ng-content&gt;
Multiple content slots can be used with multiple ng-contents. This is how you would do it: In the parent template:
&lt;div someattr1&gt; &lt;!-- stuff for first content slot --&gt; &lt;/div&gt; &lt;div id=&#34;whodisboi&#34;&gt; &lt;!-- stuff for second content slot --&gt; &lt;/div&gt; The HTML content within those slots can be used like so:
&lt;header&gt; &lt;ng-content select=&#34;[someattr1]&#34;&gt;&lt;/ng-content&gt; &lt;/header&gt; &lt;section&gt; &lt;ng-content select=&#34;#whodisboi&#34;&gt;&lt;/ng-content&gt; &lt;/section&gt; The select attribute of ng-content takes in CSS selectors to match the HTML content from the parent.
The ng-container tag itself will not be present in the DOM. Accessing DOM with viewChild # To access the DOM of the HTML of a component:
Give it a temp-ref-var like so: &lt;div #theBestElem&gt;&lt;/div&gt; Create a property on the component decoreated by viewchild like so: viewChild('theBestElem') goodie: ElementRef The selector could also be a component / directive / service class You can then access its DOM properties or get even more granular control with nativeElement. Lifecycle # A component goes through a set of events during its lifecycle. It&rsquo;s possible to &ldquo;hook&rdquo; to those events (i.e., perform some extra actions you want). Some of these hooks are:
ngOnInit ngOnChanges ngAfterContentInit ngAfterViewInit A full list of them, when they&rsquo;re called and what they do is present in the docs
And some good examples for each one are in this article
Dynamic loading! # It is possible dynamically add new components to the DOM from JS. The two options are:
&lt;ng-container *ngComponentOutlet=&quot;expressionWhichReturnsAComponent&quot;&gt;&lt;/ng-container&gt; ViewContainerRef, createComponent function. `}),e.add({id:6,href:"/java/modules/",title:"Mods & Packs",section:"Java",content:` Modules &amp; Packages # How is java code bundled up to be shared? Previously it was through packages and classpath. After project jigsaw, it is through modules.
What are they? How are they different?
Good resources for the same:
https://dev.java/learn/packages/ https://dev.java/learn/modules/ https://dev.java/learn/jlink/ `}),e.add({id:7,href:"/spring-boot/",title:"Spring Boot",section:"Introduction",content:` Spring Boot # To display dynamic data on web pages, the page usually sources it from a server running a back-end framework. While python&rsquo;s got plenty of back-end frameworks that are easy to use (e.g., FastAPI), Spring Boot seems to be more popular and more performant. Might be a good idea to learn that. Apparently, it is the next iteration of the Spring Framework. So I should probably look into that first.
What&rsquo;s Spring # Spring is a collection of projects like Spring Boot, Spring Framework, Spring Data, Spring Security etc. Spring Framework is the most popular Java framework. What exactly does it do? Let&rsquo;s find out.
Learning Journey # As usual, there&rsquo;s a helpful Pluralsight course to get an overview and pratcise: Spring Framework: Spring 5 Fundamentals
Go through the Baeldung Spring tutorial.
One of the core concepts seems to be that of dependency injection. Baeldung&rsquo;s got a tutorial for that! Dependency Injection in Spring
Finally, time to learn Spring Boot. Spring Boot tutorial and a project too.
What project? A shopping cart with the Punk API
// TODO: seems like there should be more projects
Some offical resources:
Spring Boot reference An overview of Spring Boot Fun stuff # Here&rsquo;s some fun stuff to read:
What distinguishes REST from other architectures? HATEOAS
How to manage JDK installations on your Linux machine? Use SDKMAN!. Which is sort of like nvm but it also manages versions of Java SDKs like Gradle, Groovy, Scala, Apache Tomcat etc. Sounds more like apt now.
What&rsquo;s more, it lets you set SDKs per project too.
Want to revise your basics in Java? Check this out : https://www.baeldung.com/java-tutorial `}),e.add({id:8,href:"/misc/typescript/",title:"Typescript",section:"Fun Stuff",content:` Write JavaScript with confidence # The docs are good. Check them out: https://www.typescriptlang.org/docs/.
Overview # It&rsquo;s a superset of JS that compiles to JS. You can adding typing via syntactic sugar which helps catch bugs when you compile. It also has editor plugins for the same. You can try it out online. Its main features are:
Static typing # You can declare types while declaring variables, like so: let var: number;.
Interfaces # They let you define a structure that objects must follow. An interface is a type. When you assign an object to a variable of that type, the object must have the properties in that interface (each of the same type). Like so
interface nice { name: string, age: number } let sic: nice; sic = { name: &#34;hai&#34;, // adding, removing, or changing the types of these properties causes an error age: 10 }; Class properties # ES6 classes mainly define their properties via their constructors. TS lets you to define these properties in the class itself. You can optionally specify types for them. This is only for readability. E.g.
class Hip { num: number wutdis constructor() { this.num = 10; this.wutdis = &#34;hmm&#34;; } } Public / Private access # All class properties in ES6 are public. You can make them private in TS by adding the private before them during declaration. It also provides this nifty shorthand for the constructor:
class Hip { constructor(public wutdis: string, private num) { // it implicitly does this.wutdis = wutdis } } let f = new Hip(&#34;sic&#34;, 10); console.log(f); // { wutdis: &#34;sic&#34;, num: 10 } Some notes # declare a in TS is used to tell the compiler that the variable a is declared somewhere else and it&rsquo;s usage in this file should not throw an error. (e.g. it&rsquo;s declared in another file and both of them are used via script tags in HTML)
Any definitions in a class declaration are moved to the constructor when the code is transpiled to JS. The code is also moved to the top of the constructor so that the constructor code can use the defined values. e.g. TS # class LOL { private a: number; private b: string = &#39;bob&#39;; private c = &#39;wow this is cool&#39; + this.b; constructor() { this.a = 1; this.b = &#39;wow&#39; + this.c; } public z = &#39;bongo cats&#39;; } Compiled JS # class LOL { constructor() { this.b = &#39;bob&#39;; this.c = &#39;wow this is cool&#39; + this.b; this.z = &#39;bongo cats&#39;; this.a = 1; this.b = &#39;wow&#39; + this.c; } } Testing # It can be somewhat painful.
A really good series about JavaScript testing (specifically about Jasmine and some parts about Karma) - https://www.youtube.com/playlist?list=PL_euSNU_eLbcpJdoM-WWzUlNNVM4TwtMl
1. Make a new tsconfig file # Aside from the tsconfig file that you&rsquo;re already using for your source code. Something like this (in tsconfig.callitwhatyouwant.json)
{ &#34;compilerOptions&#34;: { &#34;module&#34;: &#34;commonjs&#34;, // required for tests &#34;target&#34;: &#34;es5&#34;, &#34;lib&#34;: [ &#34;es2015&#34;, &#34;es2016&#34;, &#34;es2017&#34;, &#34;dom&#34; ], }, &#34;include&#34;: [&#34;src/**/*.ts&#34;, &#34;./test/**/*.ts&#34;] } remove stuff at your own risk. (But do try, this is somewhat of a mess)
2. Install stuff # I&rsquo;m using Karma and Jasmine cuz they&rsquo;re nice.
npm i -D karma karma-chrome-launcher karma-spec-reporter npm i -D typescript karma-typescipt karma-typescript-es6-transform npm i -D jasmine-core @types/jasmine karma-jasmine 3. Setup the karma config file # this should do
// karma.conf.js module.exports = function (config) { config.set({ frameworks: [&#34;jasmine&#34;, &#34;karma-typescript&#34;], files: [ &#34;src/**/*.ts&#34;, &#34;test/**/*.ts&#34; ], preprocessors: { &#34;**/*.ts&#34;: &#34;karma-typescript&#34; }, reporters: [&#34;progress&#34;, &#34;karma-typescript&#34;], browsers: [&#34;Chrome&#34;], karmaTypescriptConfig: { tsconfig: &#39;tsconfig.callitwhatyouwant.json&#39;, bundlerOptions: { transforms: [ require(&#34;karma-typescript-es6-transform&#34;)() ] } }, singleRun: true }); }; 4. Setup the package json # Nothing really.
&#34;scripts&#34;: { &#34;test&#34;: &#34;karma start&#34;, } That&rsquo;s it. Nothing else is required in that file.
5. Write code &amp; tests # Write them under src/ and test/ respectively.
`}),e.add({id:9,href:"/java/",title:"Java",section:"Introduction",content:` Java # The corporate programming language.
It&rsquo;s got a large ecosystem of supporting projects and is somewhat easier to use than C++.
The general idea is that the JVM has been optimized so much over the years that Java programs aren&rsquo;t slow-by-default anymore.
I know a decent amount of Java, but not enough. I still don&rsquo;t know what classpaths and packages are.
Plan # Setting up a development environment. Learn a bit about the internals of the JVM. A playbook for common tasks. Refactoring code according to SOLID principles. Is this too unorganized? There&rsquo;s a more structured way to learn Java : dev.java that you could follow.
Do something with this? # So many courses and tutorials. What do I do with this knowledge? ðŸ¤” No idea, honestly.
Fun facts # There&rsquo;s a bunch of FAQs on the Collections API. About their design.
`}),e.add({id:10,href:"/java/jvm/",title:"JVM",section:"Java",content:` The Java Virtual Machine # It executes the bytecode apparently.
Learn more about it&rsquo;s internals through these courses:
Memory Management Class Loading `}),e.add({id:11,href:"/angular/template/",title:"Template Syntax",section:"Angular",content:` The template syntax # The template builds the HTML content that is displayed for a component. It is HTML with some Angular template syntax which lets you make the component reusable.
There are HTML attributes and there are DOM properties. Sometimes there&rsquo;s a one-one mapping between them, sometimes an attribute exists but has no corresponding property and vice-versa.
Binding in HTML JS in HTML? # There are multiple ways you can use JS objects in HTML. Two of them are:
Interpolation # In places within the HTML where you can put custom values (within tags, properties of attributes, etc) you can use the result of a JS expression like this: &lt;div&gt;{{ some JS expression }}&lt;/div&gt;. All the public properties of the component class are available. The result is always a string. This is because the toString() method is called on the result of the expression. The binding between the class properties and the text is one way. Updates to the property will be reflected in the HTML but not the other way around.
The variables referenced within the expression could come from multiple places, the order of search is:
The template variable name. A name in the directive&rsquo;s context. The component&rsquo;s member names. Interpolation is secure since Angular will process the text to make sure any HTML / JS the user might have provided is not executed, only displayed on the screen.
Prevent interpolation from executing the expression using ngNonBindable like so: &lt;a ngNonBindable&gt;{{ &quot;will&quot; + &quot; not execute&quot; }}&lt;/a&gt;
Property binding # HTML elements have properties e.g. &ldquo;class, style, action, id, nonce, etc&rdquo;. You can set the values of these properties, like so: &lt;div [nonce]=&quot; some JS expression &quot;&gt;&lt;/div&gt;. The result is not converted to a string.
If you don&rsquo;t have the square brackets, the expression is not evaluated, it&rsquo;s treated as a string. i.e., &lt;a val=&quot;12+45&quot;&gt;&lt;/a&gt; will set the property val as '12+45' while &lt;a [val]=&quot;12+45&quot;&gt;&lt;/a&gt; will set it as 57.
Angular sanitizes values passed to a property to prevent XSS.
Rules for expressions # You can&rsquo;t use a few things, like these:
Assignment operators The new keyword to create objects ; to use multiple expressions Global namespace objects like console, window, etc. In general, here are a few guidelines you should follow:
The expression shouldn&rsquo;t have side effects Try to keep them simple and fast Event binding # HTML elements also have events that they can emit e.g. &ldquo;click, focus, hover, etc&rdquo;. You can bind these events (which means running code when it emitted) to statements, like so: &lt;div (hover)=&quot; some JS statement &quot;&gt;&lt;/div&gt;.
Rules for statements # Statements can have assignments but only with =, not += or other stuff. They can have multiple expressions separated by ; but the other restrictions that held for expressions still hold. They mostly do have side effects.
Two way binding # This can be done like so : &lt;child-elem [(lol)]=&quot;someVal&quot;&gt;&lt;/child-elem&gt; which does a bunch of things:
The child element should have a property &ldquo;lol&rdquo; and an EventEmitter &ldquo;lolChange&rdquo; The parent should have a property &ldquo;someVal&rdquo; Whenever someVal is updated, lol will get the new value, just like normal property binding Whenever lolChange emits a value, someVal will be set to that value. *ngFor # ngFor is a structural directive. That means that it is capable of changing the DOM structure. It works like a for loop, where for each iteration it creates another instance of the element (and its children) on which it is called. It also provides a template reference variable for the element / its children to use. An example below:
&lt;!-- x is the templ ref var and y is a property of the comp class --&gt; &lt;figure *ngFor=&#34;let x of y&#34;&gt; &lt;img [src]=&#34;x.imzSrc&#34;&gt; &lt;figcaption&gt;{{x.imzCap10}}&lt;/figcaption&gt; &lt;/figure&gt; undefined values # When you try to access an undefined value within a template, Angular will not display that element and it will throw an error in the console :(. If you are expecting something to be undefined you can use the JavaScript safe navigation operator ?. which returns undefined if its LHS is undefined else goes ahead. Check out the syntax on MDN.
*ngIf # ngIf lets you conditionally render the element it is put on. It decides this based on the expression provided to it, like so: &lt;img *ngIf=&quot;some JS expression&quot;&gt;. The component corresponding to the element (if ngIf is used on a component element and not a standard HTML Element) will be deleted too, thus freeing up memory.
It is important to note that in case the condition is falsy, the entire element is commented out. It&rsquo;s not just hidden by some CSS / HTML property. In case some operations are done when the element is rendered and it is added / removed multiple times, it can slow down performance.
If you want to hide and un-hide the element multiple times you can do so with the HTML attribute &ldquo;hidden&rdquo; which you set like so: &lt;img [hidden]=&quot;some JS expression&quot;&gt;.
ngSwitch &amp; co # This is to ngIf like a switch case is to an if condition. You define the switch condition like so: &lt;div [ngSwitch]=&quot;&quot;&gt;&lt;/div&gt;. On the children you can use either:
&lt;img *ngSwitchCase=&quot;&quot;&gt; to compare particular JS objects (objects, not just strings) OR &lt;img *ngSwitchDefault&gt; which will come to life if none of the other cases matched Attribute binding # It&rsquo;s recommended to use property binding wherever possible but sometimes the required element property does not exist. Some SVG attributes cannot be set via property binding because they have no &ldquo;property targets&rdquo;.
The simplest way to do this is: &lt;elem [attr.whateverattributename]=&quot;expr&quot;&gt;&lt;/elem&gt;. Note that the attr. prefix is necessary. If the expression evaluates to null or undefined the attribute is removed from the element.
Adding classes # There are multiple ways to do this. The simple way is for a single property like so: &lt;img [class.klassname]=&quot;bool JS expression&quot;&gt; which will add the class &ldquo;klassname&rdquo; to the element if the expression is truthy.
When you want to add multiple classes you can do so with ngClass like so &lt;img [ngClass]=&quot;fancy stuff&quot;&gt; where &ldquo;fancy stuff&rdquo; can be any JS expression that returns one of these:
An object, where the keys are class names and values are booleans which decide if that class will be added A string of space separated class names An array of strings, each of which are class names A function that returns any one of the above (just the function name, don&rsquo;t call it!) Adding styles # The simple way to set a style would be using attribute binding like so: &lt;elem [style.width]=&quot;CSS.px(10)&quot;&gt;&lt;/elem&gt;. It&rsquo;s also possible to set multiple styles like so: &lt;a [style]=&quot;{width: '100px', height: '2px'}&quot;&gt;&lt;/a&gt;.
ngStyle can also be used to set styles. ngStyle has a similar syntax to ngClass except that the return value of the expression should be an object where the keys are CSS style keys and values are CSS style values. A small example: HTML element with &lt;img [ngStyle]=&quot;komPute&quot;&gt;. The function:
komPute() { if(/* condition */) return {&#39;background-color&#39;: &#39;red&#39;, display: &#39;inline&#39;}; return {display: &#39;block&#39;}; } Template reference variable # They help you use one part of a template in another. You can declare a variable on a tag, a component, or a bunch of other things as seen in the docs. For a tag, it is a reference to the TS object of that tag and for a component it a reference to an object of that child component class. If you define one in an ngIf or an ngFor you can&rsquo;t access it outside those boundaries. This is how you use them:
Declare the variable like this &lt;comp-or-tag #refVar&gt;&lt;/comp-or-tag&gt; You can then use this in other parts of the template, if it&rsquo;s a component you can access its public properties. Like so, &lt;other-tag [lul]=&quot;refVar.val1&quot; (snap)=&quot;refVar.func1()&quot;&gt; {{ refVar.val2 }} &lt;/other-tag&gt; It is not accessible in the TS of the parent component. How does this work with ngModel? According to the docs:
If the variable specifies a name on the right-hand side, such as #var=&ldquo;ngModel&rdquo;, the variable refers to the directive or component on the element with a matching exportAs name.
The same case with using the ngForm directive: &lt;form #lol=&quot;ngForm&quot;&gt;. lol will have values as specified by the ngForm directive.
Styling # Write styles in the sheets provided for the components. Angular performs &ldquo;view encapsulation&rdquo; which means a component&rsquo;s styles are applied to only its elements. This happens by adding special attributes to the elements in the DOM e.g. &lt;h2 somerandomNGattribute&gt;&lt;/h2&gt; and adding that attribute to all encapuslated styles.
Styles provided in the global stylesheet are still applicable to all componenents. To remove this encapsulation you can either:
set encapsulation to ViewEncapsulation.None in the component&rsquo;s metadata add ::ng-deep to child styles. This doesn&rsquo;t remove the encapsulation but allows adding styles to elements that aren&rsquo;t in the template. That&rsquo;s not the only type of encapsulation, there&rsquo;s also:
ViewEncapsulation.ShadowDom which gives this component a shadow DOM and places elements under that shadow root. All shadow elements styles are separated from global styles. Any style declared for components within this shadow DOM are attached to the shadow root. ViewEncapsulation.Emulated is the default and sets styles for only that component&rsquo;s elements. The shadow DOM API is not available in all browsers (e.g. IE and Opera Mobile) but it&rsquo;s available in most modern ones and is available to at least 94% of all users at the time of writing this. Check caniuse Thought only HTML files could be used as templates? SVGs can be used too! ng-template # TODO: A special section on ng-template, it seems to be pretty powerful.
`}),e.add({id:12,href:"/misc/tips-tricks/",title:"Tips & Tricks",section:"Fun Stuff",content:` Tips, tricks, and resources # Modern JS has many inbuilt features, not all of them are so well known. Check them out, from the stateOfJS22
Good resource &amp; book on how to design modern web apps: https://www.patterns.dev/
Variable hoisting was an unintended addition that came along with function hoisting when JS was being developed. Hoisting is done by the two-scan interpreter. The first scan is to find declarations. This stackoverflow q&amp;a has some good answers. There&rsquo;s no concept of &ldquo;initialization&rdquo; in JS. There is declaration (let a) and there is assignment (a = 2). &ldquo;Definition&rdquo; is just syntax sugar to do both declaration and assignment at once. typeof null evaluates to 'object' in JS. Which is a bug apparently. While writing the CSS for a site, it&rsquo;s a good idea to write it mobile first and then add media queries for the larger screen sizes. It leads to less CSS. Even if the design was desktop based. JS has so many inbuilt things. Proxy is one of them. Want to know if you&rsquo;ve covered all best-practices and stuff for your web app? There&rsquo;s a nice checklist A book about building web apps by Basecamp. It&rsquo;s good apparently. PDF also available. Confused about what units to use in CSS? Check out this video by Kevin Powell Use rem (i.e., root el) for fonts and most other things. It&rsquo;s relative to the font-size of &lt;html&gt; (which is 16px by default) em is relative to the font-size of the element it is on or the closest parent which has defined a font size. When it&rsquo;s used for some other property, it only references this element&rsquo;s font-size. It can be useful for padding and margins. Use percentages for width (prefer to use max-width) or ch (equal to width of a char) when operating on a text container Think twice before setting height. Try to set min-height if it is really needed. Try to keep text confined to 60 chars a row. There&rsquo;s an open source design tool: Penpot which focuses on web standards The word &ldquo;JavaScript&rdquo; is trademarked by Oracle ( https://tinyclouds.org/trademark) as of Sept. 2022 An easy way to locally deploy the built application is to run: python -m http.server --bind localhost 8080 which serves the current directory at http://localhost:8080 There&rsquo;s a slight imperfection in the microsoft logo on black backgrounds where the red box seems to appear larger than the blue box below it. This is due to the way pixels are arranged in a display. See it in more detail here Want to see what are the new features in es6 and how many of them could be done in previous versions? This website lets you do that. Reference for JavaScript and some practice exercises : https://wesbos.com/javascript Browsers now have better client side functioning capabilities. Such as a proper DB, virtualfile system, and even running full programs `}),e.add({id:13,href:"/java/build_tools/",title:"Build tools",section:"Java",content:` Building Java code # Why not just use javac ? Well, you can but tools save time because there could be:
Many Java files that need to be compiled for the main file. Incremental builds, building only the classes whose code has changed. External dependencies that need to be fetched. (Transitive dependencies! Versions!) Package code into a .jar or .jmod file. Custom arguments for compiling certain classes ? Custom arguments for running the tests. This is what tools like maven and gradle try to solve.
Compile and execute with external libraries # Suppose you wanted to use the jackson-databind package, how do you do it manually?
Use the classes from the library in your code, e.g.: import com.fasterxml.jackson.databind.ObjectMapper; class A { void fun() { ObjectMapper mapper = new ObjectMapper(); } } Download the jar file for the package from maven-central. You will now have a file like so: jackson-databind-2.15.2.jar Compile your java file, i.e., A.java like so: javac -cp jackson-databind-2.15.2.jar A.java Download the jar files for all transitive dependencies of jackson-databind, which happen to be jackson-annotations-2.15.2.jar and jackson-core-2.15.2.jar. Execute your class like so: java -cp jackson-databind-2.15.2.jar:jackson-annotations-2.15.2.jar:jackson-core-2.15.2.jar:. A (note that the current directory was put on classpath as well, this is so that it can find class A) What&rsquo;s the default classpath? The current directory from where you are executing java.
Will it search recursively in the classpath directories trying to find your files? No.
There is no trying. It will look in the exact location. Nothing else.
There&rsquo;s also -module-path ??
The javac command also requires the -cp argument when there are dependencies. You can see which class files and source files it loads by passing the -verbose option. The command doesn&rsquo;t just compile the .java file you have specified, it would compile any other .java files that your file uses and don&rsquo;t yet have corresponding .class files.
History of build tools # javac and java, the only things you really need make to reduce the commands you need to write ant, as a platform-independent alternative, and was customized to work better with java (e.g., compiling multiple source files at once, rather than one at a time, as each dependency is found. scanning folders for java files, rather than having to add them one by one as new files are added.). ivy was developed to do dependency management for it. maven, which added many conventions over configurations, and plugins to make config files smaller, and makes them uniform. still in XML. gradle, which brought a DSL to do things programatically Third party dependencies # Where are these located? Nowadays, most of them are hoste in maven-central (sort of like npm).
Maven # Helps in managing project dependencies, build / test tasks, and documentation. You can the project info in a declarative format in pom.xml.
Setup # Download and install mvn in your system. The MAVEN_HOME variable is required to be set in the parent dir of bin where mvn is present.
Gradle # Similar objectives to Maven, but you can specify the project info in a &hellip; scripting language format. With Groovy / Kotlin.
Can help in reducing duplication.
Setup # Download from gradle.com, and you have the gradle binary. It uses GRADLE_USER_HOME where it places temporary files. Once you have an inital binary on your system, you can add gradle &ldquo;wrapper&rdquo; files for each project.
That way, you can specify which version of gradle should be used for that project, and it will download the binary specifically for it (if not already there).
This also means that anyone downloading your code and running it, just needs to have the JDK installed, and nothing else.
Gradle (In Detail) # Compile and run your code with doing the least amount of configuration.
There are .gradle files which define tasks which can build / run / test your code. The default one is build.gradle.
Those files are defined in the Groovy language by defualt. You can also have &ldquo;builds&rdquo; in the Kotlin language, in build.gradle.kts files.
Gradle itself runs on the JVM, since it is built using Java. You can choose which JVM it should run on.
Build # Gradle uses a concept of &ldquo;build&rdquo;. A project having a build.gradle file is called a build. Nearly every gradle command runs wrt a &ldquo;build&rdquo;.
You can create such a buildscript for your project by doing gradle init (which also adds extra stuff e.g., wrapper &amp; settings.gradle files)
There is a build lifecycle which happens when gradle xyzTask is run. It does &ldquo;initialization&rdquo;, which is reading the settings file, then does &ldquo;configuration&rdquo;, which is executing the buildscripts for each project involved, creating the task graph etc., then does the actual execution of each task involved.
This means any code written outside of a task defintion in the buildscript will be executed in the configuration phase.
Tasks can be chosen to run in parallel with the --parallel flag.
Gradle provides the ability to specify which Java version must the code / generated class files comply with. This can be set via sourceCompatibility, targetCompatibility, but it is preferred to set a toolchain instead.
The toolchain lets users specify which JRE / JDK (if required) must be found (or downloaded) for compiling / other tasks of the build.
It is specified like so:
java { toolchain { languageVersion = JavaLanguageVersion.of(21) // optional vendor = JvmVendorSpec.AZUL_ZULU // optional } } It is also possible to specify different java version requirements for each task separately, in which case those multiple versions are part of the toolchain.
Tasks # They have lifecycles, and we can add code to run at some stages of these lifecyles, through some lifecycle hooks.
Then you can invoke the task from gradle e.g., gradle myNewTask, and that will go through full life cycle of the task.
Run gradle tasks to see all available tasks for the &ldquo;build&rdquo;.
Some lifecycle hooks which are called during a task&rsquo;s execution lifecyle are doFirst, and doLast.
Tasks are objects of the Task type, and are instances of the DefaultTask class by default.
There are other inbuilt Task sub-classes as well e.g., Copy, Jar, Zip etc. of which task objects can be instantiated.
To know more about a task, run gradle help --tasks taskName.
It is also possible to define a new task class which takes inputs &amp; produces outputs. Those are of types TaskInputs, and TaskOutputs, and are defined with one of the @Input, or @Output annotations e.g.,
abstract class TestTask : DefaultTask() { @Input val xyz = &#34;&#34; @OutputFile val abc: File = File(&#34;/var/tmp/hi.txt&#34;) @TaskAction fun someFuncName() { abc.createNewFile() } } To add dependencies between tasks, just set the dependsOn property in the depending task.
The list of all tasks are available in a TaskCollection, which is by default called tasks. To add to it, we do tasks.register(&quot;newOne&quot;), and to fetch we do tasks.named(&quot;newOne&quot;)
The @TaskAction annotation defines the function which should be run when an task of that class is invoked.
That function is called after doFirst, and before doLast. It is also possible to create tasks which don&rsquo;t have any action at all e.g., build. They can have other properties and functions, but don&rsquo;t really have an action to do by themselves. They are known as &ldquo;lifecycle tasks&rdquo;
Projects # When you run gradle inside a &ldquo;build&rdquo;, it first looks for the settings.gradle file, creates a &ldquo;Settings&rdquo; object, determines which projects are in the &ldquo;build&rdquo;, and then looks for the buildscripts (some *.gradle file) for each of those projects to construct &ldquo;Project&rdquo; objects. There is only one root project for each &ldquo;build&rdquo;.
Plugins # These add extra tasks to the &ldquo;build&rdquo; and extra properties too. Once you add a plugin, you can re-run gradle tasks to see what new stuff is there. Plugins can be added via plugin { id: 'java' } in the buildscript or apply plugin 'java' (deprecated).
Some of the commone ones are:
java - adds some tasks to build, test, and package code, docs etc. uses some conventions to determine where source files, resources etc. are application - adds tasks to run app, generate dists and run scripts java-library - adds properties, and splits dependencies into api and implementation Plugins themselves can extend other plugins. Therefore, if you have java-library, it will implicitly import the java plugin as well.
The java plugin knows where to look for the code via some default paths in sourceSets. If a project has a different layout, it can set the sourceSets to the custom paths.
Where does gradle get the plugins from? Some are inbuilt. The third-party ones are available here: https://plugins.gradle.org/. If you want to get them from a custom repository, you&rsquo;ll need to set the URL in pluginManagement in the settings.gradle.
It&rsquo;s also possible to set plugin versions inside the pluginManagement block and is more preferred as you can use variables (not possible in plugin {}).
Syntax # The groovy &amp; kotlin buildscripts have stuff like this:
plugins { id(&#34;plugin&#34;) } That&rsquo;s a shorthand for this code which uses a lambda function:
plugins(function() { id(&#34;plugin&#34;) }) where id is a method of a &ldquo;this&rdquo; object which is identified by Gradle. so something like this:
ext { wassup = &#34;hi&#34; } might do ext.setWassup(&quot;hi&quot;)
how are so many objects, and methods available in the script files? gradle auto-imports them.
Dependencies # How to use other people&rsquo;s code in your project. You can depend on external / internal libraries, projects.
Dependencies are fetched from a &ldquo;repository&rdquo;. Each dependency is assumed to be a java module. Repository could be a directory on the file system, a web server serving files via the maven / ivy spec (which means either providing maven POM files or ivy XML files, or even a .module file). The metadata file for each library will tell where to get the jar file / other dependency &ldquo;artifacts&rdquo; from. It also has other metadata like author info, transitive dependencies info, etc. Usually the metadata file and artifacts are in the same location.
Once artifacts are fetched, they are kept in a cache (along with metadata files, albeit in a diff place) in the file system for quick use.
Different dependencies can be required at different times, e.g., some for compiling, some for running, some for testing etc. Gradle helps in specifying different scopes for each one. The main scope is the implementation scope, which sets runtimeOnly and compileOnly scopes. The testImplementation scope inherits from implementation and it also sets testRuntimeOnly, and testCompileOnly. There are many other scopes too, and plugins can define their own.
However, that&rsquo;s not what is actually used by the build, run, and test tasks. They use compileClasspath, runtimeClasspath, testCompileClasspath, which are resolvable configurations (meaning it will go and find the jars &amp; transitive dependencies etc) and inherit from implementation, compileOnly, etc. which is where you actually list the deps that you want.
Each dependency can be represented by a string &quot;groupId:artifactId:version&quot; or longer group &quot;&quot; name &quot;&quot; version &quot;&quot;.
If there&rsquo;s multiple GAV modules, they can be specified with a &ldquo;classifier&rdquo; suffix, which comes after the version.
When creating a library, it is possible to get library dependencies using the &ldquo;api&rdquo; scope if these dependencies might be exposed to library consumers, e.g., via method parameters / return types. This way, the consumer will get the library in their list of dependencies.
Multi Projects # Gradle provides support for multiple subprojects (AKA modules) within your top-level project. Each of them have their own buildscripts.
There is a top-level settings &amp; can be a top level build script as well, but there is always a top level project (AKA root project).
Although each one can specify their own plugins &amp; dependencies, they are managed and stored in one place.
Once you create a separate folder for each project &amp; give each one a build script, you can add these projects to the settings like so:
rootProject.name = &#34;fun1&#34; include(&#34;fun2&#34;, &#34;fun3&#34;) and upon running gradle projects, you can see the project tree like so:
Root project &#39;fun1&#39; +--- Project &#39;:fun2&#39; \\--- Project &#39;:fun3&#39; Executing tasks # You can step into any of the subdirectories and run tasks e.g., gradle funTimes and it will run the funTimes task on the sub-project and all its sub-projects which have this task defined. You can also run it for a particular project by giving the fully qualified project name e.g., :fun2:funTimes. The root one doesn&rsquo;t need any qualifiers.
But if you want to run only for the root, you do so by running gradle :funTimes.
Configurations # You can specify specify some settings e.g., properties, dependencies for subprojects, or allprojects if you want to define some common configurations to be shared across multiple projects. Even project specific stuff can be added via project(&quot;:fun2&quot;) {}.
It&rsquo;s also possible to apply plugins for the root &amp; subprojects in one place. It is also possible to fetch it in the root project &amp; apply in the subprojects only. e.g.,
plugins { id(&#34;funplugin&#34;) version &#34;x&#34; apply false } and use in subproject like so:
plugins { id(&#34;funplugin&#34;) } Dependencies # It is possible to use one subproject in another. It can just be added to the dependencies block of the consumer project with the required scope. E.g., implementation project(&quot;:fun3&quot;)
Fun stuff # Gradle supports &ldquo;continuous invocation of tasks&rdquo; based on files changing. This can be done by adding the --continuous flag. You needn&rsquo;t write the full name of a task. If you have tasks &lsquo;projects&rsquo;, and &lsquo;properties&rsquo;, you can just do gradle proj to run the first one. `}),e.add({id:14,href:"/misc/js-execution/",title:"JavaScript execution",section:"Fun Stuff",content:` How does JS run in the browser &amp; node? # If you prefer visuals over text, these talks are really good (videos aren&rsquo;t mine):
WTH is the Event Loop? Further Adventures of the Event Loop Jake Archibald on the Event Loop Overview # The v8 runtime provides a call stack and heap. Then in the browser, we have the WebAPIs, which provides FUNctions which can make code execute elsewhere. We have :
Task queues (sometimes called Macrotask queues) Microtask queues Rendering pipeline All these are enough for async single-thread execution of JS.
To do parallel exec, the browser provides Web Workers. Those have their own task &amp; microtask queues. However, they can&rsquo;t maniupilate the DOM and they don&rsquo;t have any rendering pipelines. The single rendering pipeline runs in the main thread.
In the case of Node, it has similar task &amp; microtask queues, but bit different kinds than those in the browser.
Fun fact, after going through the talks, it should make sense why this code will never cause el to appear on the screen:
document.body.append(el); el.style.display = &#39;none&#39;; Think you know it all? Good for you. Test out your skills with these questions.
Event loop # The event loop is a piece of code in the browser (and nodeJS as well, but it&rsquo;s bit different in node), that looks for something to execute from the queues (it has a priority order to decide which queue) and then puts that on the call stack.
It doesn&rsquo;t do anything as long as there is something executing in the call stack. It will wait for all that to be done before picking up the next task (yes, even page repaint is a task)
Task Queues # Wait what? There should be only one right? Haha, no. There can be one for network events (fetch), setTimeouts and other use a different one. That&rsquo;s why fetch completes before setTimeout even if setTimeout may queue the task first. Calling setTimeout won&rsquo;t queue a task, it will do it after its waiting time.
Microtask Queues # Tasks from this queue are executed immediately when the call stack is empty. Thus, these can be executed even in the middle of a regular task (NOT WHEN JS CODE IS EXECUTING ON THE STACK). Whaaat? it&rsquo;s possible that a task is executing without JS code? Yeah. Imagine an event, after each node that it bubbles on and executes listener callbacks, there is no code on the call stack, but since it is still bubbling, the task itself is not done. Hence, microtasks can execute in between this task, but regular tasks will have to wait for all the bubbling etc to be complete.
When the event loop picks up microtasks, it drains the queue till is empty. What action puts tasks in the microtask queue? Promises and Mutation Observers.
Fun fact, the browser doesn&rsquo;t add a new mutation observer task on the same element-attribute combo if one is already pending in the queue.
Rendering pipeline # The browser provides us a way to add tasks to the rendering pipeline, through a &ldquo;rendering queue&rdquo;. When the event loop starts processing this queue, it drains the queue till all existing tasks of the queue are processed. How to add things to this queue? requestAnimationFrame(callback). The rendering pipeline consists of first executing tasks from rendering queue and then performing CSS calculations and painting. The event loop looks at this queue every 16 ms (if it&rsquo;s a 60Hz screen), unless it&rsquo;s in the background. Remember, the event loop cannot look at this queue if there is something being executed on the call stack. Also, it will check the microtask queue first, before looking at this queue.
Web Workers # Web workers and cross-origin iframes are said to have their own runtimes. Meaning, they will have their own queues, stacks, and heaps. Runtimes can communicate using the postMessage function.
Events # Well, it&rsquo;s called the event loop after all. So when do browser events such as clicking a button get executed? What if the button is programatically clicked through JS?
The click event (as an example) causes the browser&rsquo;s event processing task to be added to the queue. When that task is picked up by the loop, it goes through the DOM tree and executes all the event listener callback functions on the element it encounters.
If the click event task is programatically called (e.g., el.click()), all the callbacks are added to the call stack. All the event listener callbacks can be synchronously added to the call stack via dispatchEvent(event: Event). Events dispatched programatically also follow all the regular bubbling and capturing rules.
When adding multiple callbacks via addEventListener, it&rsquo;s not guaranteed which one will be added the queue first.
Generators # These are similar to Python generators. You can define one like so:
function* ayo(val) { yield &#39;x&#39;; yield &#39;y&#39;; yield &#39;z&#39;; } const genr = ayo(); console.log(genr.next()); // {value: &#39;x&#39;; done: false;} console.log(genr.next()); // {value: &#39;y&#39;; done: false;} console.log(genr.next()); // {value: &#39;z&#39;; done: false;} console.log(genr.next()); // {value: undefined; done: true;} const othergen = ayo(&#39;hey there&#39;); like an array, you can iterate over them.
TODO : Learn more about them here : https://javascript.info/generators
Execution flow : # JS is an interpreted language. Here is how the JS execution engine in the browser handles it.
Parse a line Compile Optimize Execute Garbage Collection However, to make if faster, there is a Just-In-Time compiler, which is done by monitoring the code for hot-spots (e.g., code run frequently) and then compiling / compiling with optimizations so machine code is available fast.
WebAssembly is faster because it is precompiled and optimized for the architecture. Often the machine code it produces is more optimized than the one JS engine produces.
`}),e.add({id:15,href:"/linux/",title:"Linux stuff",section:"Introduction",content:` How does computer software work? # Especially the ones running on a Linux OS.
TODO # Linux Audio. How does it work, how does it break so easily, and how can it be fixed. Understand output of inxi -SMAz `}),e.add({id:16,href:"/angular/services/",title:"Services",section:"Angular",content:` Services (do STUFF) # They are classes where you can put business logic for components. They should be specific. Components and services should be as reusable as possible. This is a good, short read about them: Services and DI.
According to that page linked above:
A component can delegate certain tasks to services, such as fetching data from the server, validating user input, or logging directly to the console
Creating them # You usually create one in a .service.ts file. It is an exported class with functions which perform the required business actions. It can then be injected into the required classes. It might depend on other services too.
Providers tell injectors how to obtain or create the required dependencies.
Using them # Services don&rsquo;t just need to be provided in modules or the root, it&rsquo;s also possible to provide a service object just for a component by setting the providers property in the component metadata.
Read more about dependency injection here.
`}),e.add({id:17,href:"/angular/directives/",title:"Directives",section:"Angular",content:` Directives: Hmmm &hellip; # These are just classes that add extra behavior to elements ~ Angular docs.
Components are represented in HTML as elements. Directives are represented as attributes on those elements. A directive can also be applied on a simple HTML element, not just components.
Creating them # You can create a directive class in a file like nice.directive.ts like so:
import { Directive, OnInit } from &#39;@angular/core&#39; Directive({ selector: &#39;&#39; // CSS style selector e.g. [nice-stuff] // the HTML would be like &lt;somecomp nice-stuff&gt;&lt;/somecomp&gt; }) export class NiceDirective { } They need to be added to the declaration section of the ngModule where they will be used. They can get a reference to the element they were used on via the ElementRef service which can be added as a dependency.
Raw access to the DOM element can be gotten via the ElementRef object like so: ref.nativeElement.
Passing values to it # To pass in some value you just set the value of the attribute. E.g. for a directive with a selector &ldquo;sneaky-wookie&rdquo;, do this: &lt;div sneaky-wookie=&quot;some nice string&quot;&gt;&lt;/div&gt;. This can then be accessed via an @Input() property like so: @Input('sneaky-wookie') aliasName: string within the directive class.
An alias had to be used since the directive selector had a &lsquo;-&rsquo; in it.
Builtins # Attribute # Some examples are: ngClass ngStyle Structural # Some basic stuff has been covered here in the docs: ngIf ngFor &lt;a *ngIf=&quot;expr&quot;&gt;&lt;/a&gt; is really a shortcut, it expands to: &lt;ng-template [ngIf]=&quot;expr&quot;&gt;&lt;a&gt;&lt;/a&gt;&lt;/ng-template&gt;.
It&rsquo;s possible to have an else block like so:
&lt;a *ngIf=&#34;expr; else theOtherBlock&#34;&gt;first&lt;/a&gt; &lt;a #theOtherBlock&gt;second&lt;/a&gt; If you want to be consistent you could write that as:
&lt;div *ngIf=&#34;expr; then theFirstBlock else theOtherBlock&gt; &lt;a #theFirstBlock&gt;first&lt;/a&gt; &lt;a #theOtherBlock&gt;second&lt;/a&gt; Does using a &lt;div&gt; there seem weird? It&rsquo;s possible to use &lt;ng-container&gt; instead. It doesn&rsquo;t even get output into the final HTML Want to have an index while looping with ngFor? Do this:
&lt;div *ngFor=&#34;let item of items; let i=index&#34;&gt;{{i + 1}} - {{item.name}}&lt;/div&gt; When the list that ngFor is rendering changes, it&rsquo;s possible to optimize the rendering by only rendering the elements that have changed (modified / removed / added). This is done with trackBy:
&lt;div *ngFor=&#34;let item of items; trackBy: (i, d) =&gt; d.id&#34;&gt; ({{item.id}}) {{item.name}} &lt;/div&gt; ngFor has a bunch of local variables which can help reduce template code. They can be found in the docs but here is an example:
&lt;li *ngFor=&#34;let user of users; index as i; count as c&#34;&gt; {{user.name}} is {{i}} out of {{c}} in the list &lt;/li&gt; Attribute # How to make a custom one!
Start off with ng generate directive somecoolstuff. The base may not be enough, so set it up like this:
import { Directive, ElementRef, HostListener } from &#39;@angular/core&#39;; @Directive({ selector: &#39;[appSomecoolstuff]&#39; }) export class SomecoolstuffDirective { constructor(private el: ElementRef) { // can access DOM node with el.nativeElement } @HostListener(&#39;click&#39;) handler() { // do stuff to the element } } It can be added to an element like this: &lt;a appSomecoolstuff&gt;&lt;/a&gt;. Multiple values can be passed to it using @Input() e.g.:
@Input() randomProp1: string; @Input() randomProp2: number; which can be used like so: &lt;a appSomecoolstuff randomProp1=&quot;wowcool&quot; [randomProp2]=&quot;1+2&quot;&gt;&lt;/a&gt;.
Structural # These modify the DOM by adding / removing elements. Only one structural directive can be applied per element. It&rsquo;s possible to make your own like so: ng g directive whatADirective. The class can be modified like this:
import { Directive, Input, TemplateRef, ViewContainerRef } from &#39;@angular/core&#39;; @Directive({ selector: &#39;[appWhatADirective]&#39;}) export class WhatADirectiveDirective { private someStuff = &#39;wow&#39;; constructor( private templateRef: TemplateRef&lt;any&gt;, private viewContainer: ViewContainerRef ) { } @Input() set appWhatADirective(randomStuff: string) { // do some stuff to the view container } } which can then be used like so:
&lt;p *wow=&#34;&#39;somestring&#39;&#34;&gt; maybe do something with this content here? &lt;/p&gt; The translation between structural directive shortcuts and what Angular actually does can be found here
`}),e.add({id:18,href:"/misc/web-app-arch/",title:"Web App Architecture",section:"Fun Stuff",content:` Overall design between browser &amp; server # How do you serve content to a user in 2024? Well, the ways I know of are &hellip;
Django, or Flask (what architectres do these promote? MVC?) Spring Boot &amp; React (Single Page Apps. MVVM apparently??) Next.js (and other SSR) Hugo (Static Site Gen) Rails (MVC) Cloudflare web workers (the &ldquo;serverless&rdquo; design) Architectures # MVC # Model View Controller. Lots of strong opinions about this. Apparently, there are no MVC frameworks, but just apps which implement the MVC architecture pattern. That might be an over-simplification. There could be frameworks which make it easy to do MVC.
MVC is split into the model section and the presentation section (hence the Separation Of Concerns). Or for simplicity, like this:
Model layer contains business logic. It also handles the data persistence. View layer presents the UI, given the data to present. They are not meant for doing processing. Controller passes data between Model &amp; View, and also performs auth, handles request-response, and displaying correct View to the user. It does not handle the routing of requests i.e., matching. The model layer is an important one. It can be thought of as containing:
Domain entities, corresponding to business objects. These should contain the business logic for that entity. Data mappers, which handle conversion between domain entities &amp; persistence storage. Services, responsible for application logic, including interactions between domain entities. View layer can directly read from Model layer, just be careful so that Models are not be dependent on the UI.
The Model &amp; View layer don&rsquo;t have knowledge of the Controller.
MVP # Model View Presenter. Pretty much same as MVC, but all interactions between Model &amp; View happen through Presenter layer.
View &amp; Presenter could be aware of each other.
Model View ViewModel # The aim of this approach was to simplify the View layer. Instead of having coding logic, it just has simple bindings to the properties &amp; methods in the ViewModel layer.
The View definition could be written in a simple language e.g., XML.
The ViewModel is itself not aware of the View, and all data transfer is done through the bindings. The ViewModel layer interacts with the Model layer only.
Rendering Patterns # SPA # Single Page Apps. Built with help of libraries like React. They ship JavaScript to the client which creates the HTML pages on the fly, helping in reducing time for changes in the page.
Pros and Cons below:
Pros # Quick page-updates on user interactions. REACTIVNESS. The whole reason this became popular. Can easily work with client-side data which may change (e.g., location). Context of current state of app is easily available. Server not always required. Something like Firebase could be enough if data persistence is the only concern. Cons # First load could be slow. May be alivieated with lazy loading. But not as fast as getting HTML from server. Lots of JavaScript needs to be executed, requires some processing on the client. Systems not able to get the HTML that would be displayed to the users (e.g., robot crawler) SSR # Server Side Rendering? Isn&rsquo;t that just the classical multi-page-applications? Which MVC apps would provide? By directly sending HTML to the client?
Yes, it includes that, but it&rsquo;s a mix of SPA too. So that the reactivness of the app is still there, without full page loads.
How? The server sends a full HTML page to the client. But it also then sends a main.js to hydrate the client with reactiveness (meaning any action they perform now will not require a full page load).
If the same logic is applied for each component, i.e., the server sends the entire HTML for any component, and then provides hydration later on, that&rsquo;s called Streaming SSR.
The good part is, client side JS need not worry about what all data is required / conditions need to be applied on the HTML of a component. The server can do all the data fetches, apply conditions, and pass the end-result HTML to the client.
With React Server Components, it can also send a &ldquo;suspend&rdquo; state of the component (basically the loading indicators the component should show before the actual state is ready). Or, if that&rsquo;s not preferred, it can block till the comp is ready.
SSG # Pre-render all possible pages of the app in HTML. Minimal JS for client interaction. There is no server here, just a CDN.
For large sites with lots of pages, it would not be practical to build everything. Instead, there is Incremental Static Regeneration (ISR), which will create a static site for a page at runtime, and keep that page cached for a while. Kind of a lazy-loading SSG, but with a server.
Islands # Split page into components. Only the ones which require interactivity get JS, the rest are plain HTML blocks sent from server. Used by Astro &amp; Fresh.
Notes # Apparently, MVC of Rails is not the &ldquo;original&rdquo; MVC, but rather a version 2 designed to suit web apps. The OG one was for n-tier web apps where these could be different systems.
`}),e.add({id:19,href:"/java/web-server/",title:"Web Server",section:"Java",content:` Sharing stuff to browsers # Sure, you can use Spring MVC and others, but what about using something more low-level.
Jetty Server Jetty Servlet (to handle requests) Apache CXF (to implement REST APIs, compliant with JAX-RS) https://www.baeldung.com/jetty-embedded https://www.baeldung.com/introduction-to-apache-cxf https://www.baeldung.com/rest-api-jax-rs-vs-spring
`}),e.add({id:20,href:"/angular/routing/",title:"Routing",section:"Angular",content:` Routing &amp; Co. # Some modern apps, like the one built with Angular are Single Page Apps. They only load one HTML file from the server (index.html mostly) and then use JS to fetch new content and change parts of the page as the user navigates the site. It behaves like a regular sites in all aspects (look at the address bar) while being more efficient!
Creating routes # Routes are defined as an array of objects. The array is of the type Routes from &ldquo;@angular/router&rdquo;.
The object should be like: {path:'', component: ComponentKlass} which is of type Route. You then pass the array as an argument to RouterModule.forRoot(routes) in an NgModule of your app (e.g. AppModule in app.module.ts) If you want a route to redirect, you can set it like so: {path:'blue', redirectTo: '/red', pathMatch: 'full'} A good practice is to create a separate module for routing and then import the module in AppModule. This way, routes and the RouterModule import will be in a separate file e.g. app-routing.module.ts. The main AppModule may also choose to export the new router module you created so it will be available throughout the app.
Route parameters # You can pass parameters in a route path, like so: path: 'warehouse/:id' where &ldquo;id&rdquo; is the parameter. To access it within your component code you should:
Add ActivatedRoute as a dependency to your component Access the parameter via the dependency object, like so: route.snapshot.params[&quot;id&quot;] Angular does not reload a component when only the parameters change. This can cause issues while navigating from a component to itself. A better idea to subscribe to the params like so:
route.params.forEach((param: Param) =&gt; { // logic for updating content }) Links to routes # You want Angular to generate the links to routes, not hardcode them. This is how you do it:
Add the routerLink property to an element. As its value provide an array of path elements, like this: ['where', someParam], which will be joined with &lsquo;/&rsquo; and used. That element will be clickable and will go to that route when clicked. &lt;a&gt; elements will get an href property with the destination route as the value. Navigate with JS # You can also navigate the site, not just by clicking links, but also with JS if required. You just put Router from &ldquo;@angular/router&rdquo; as a dependency and then call routerName.navigate([/* path as an array of strings */])
There&rsquo;s also an Angular service called Location from &ldquo;@angular/core&rdquo; with which you can go back to the previous page. To use it, inject it as a dependency and then do locationObj.back().
Guards # When you don&rsquo;t want a user to visit or leave ceratin routes.
Activation # Used to prevent users from visiting a route unless some condition is satisfied. You can specify the condition via a function or service. You can do it with a service, like so:
Define a service which has a canActivate method that takes in an ActivatedRouteSnap object as a param. This function returns true / false telling if the should be able to accessed. If you want you can do things like navigate to a 404 page from that function. Pass in the service in an array as the value to the canActivate key of the Route object you wish to guard. Like so: {path: 'event/:id', component: EventDetailsComponent, canActivate: [NavigationService]} Deactivation # Used to prevent users from leaving a page (they can always leave by changing the address in the address bar) unless some condition is satisfied. You can do it with a service, or with a function, like so:
Define a function and add it as a provider. This means you need to create a Provider object and register it in the NgModule&rsquo;s providers array. It needs the provide property which is a string that you can use to access this provider and useValue property whose value the function you just defined. An example: {provide: 'dontLoseData', useValue: checkBadDataState}. The function must return true / false which determines if the user can leave the page. You can then use this provider by accessing it via its key, like so: {path: 'event/new', component: abc, canDeactivate: ['dontLoseData']} Active route # You can add classes to elements which have [routerLink] when the current page is that link. That&rsquo;s done with routerLinkActive='someKlass' property. To match exactly, you can set [routerLinkActiveOptions] to {exact: true}
Lazy loading a Module # You can lazy load a module so that it only loads under a particular route. Therefore it saves bandwidth for the user when they just visit the main site. You define the module, its routes, and its components normally. Some changes:
You import and use CommonModule instead of BrowserModule in NgModule. You use RouterModule.forChild instead of RouterModule.forRoot. Then to load this particular module on a route you can define it in the main route, like so:
{ // this is a Route object path: &#39;extraa&#39;, loadChildren: () =&gt; import(&#39;extraStuff.module&#39; /*the file where the module is defined*/).then( mod =&gt; mod.FancyModule // the NgModule&#39;d class ) } To improve perceived performance, this module can be prefetched whenever the browser is free. This can be done by adding another argument to the root router module like so:
@NgModule({ imports: [ // other modules RouterModule.forRoot(mainRoutes, {preLoadingStrategy: PreLoadAllModules}) ] }) Prefetching with resolve # When a user visits a route a resolver loads the data required for the page before the component is loaded. It helps fix issues caused when the component is ready but the data required for its content is not.
A resolver is usually a service that has a resolve method that takes in an ActivatedRoute object and returns an Observable. The observable is automatically subscribed to.
In the list of routes, for a Route object, specify a resolve property that is equal to an object where the keys can be used to access the data on the route later on. Like so: resolve: { users: getUsersService }. This can then be accessed via the ActivatedRoute like so: this.route.snapshot.data['users']
Nested routes # TODO
Extra options you can set on &lt;router-outlet&gt; # TODO
`}),e.add({id:21,href:"/misc/snowflake/",title:"Snowflake",section:"Fun Stuff",content:` Snowflake, the enterprise DB (TM) # Not exactly. It&rsquo;s a cloud data platform apparently.
Why would you need it? Otherwise, an org can have so many DBs across departments, with lots of data duplication and lesser opportunities for high level analysis across systems. Also, it is cloud native and doesn&rsquo;t expose any hardware aspects to the users.
Apparently, the on-prem structure of past solutions were not scalable and were expensive. Snowflake uses AWS, Azure, or GCP, and is a much more scalable solution, with separate scaling for storage and compute. It has a pay-as-you-go model. (Like AWS billing).
It also has very good integration with many analytics software such as Power BI, Tableau.
Architecture # Snowflake has three layers :
Cloud Service - For UI based actions. Also does metadata management, query optimization. Compute Layer - Query executor. Uses virtual warehouses (AKA warehouses) for compute. This has an inbuilt cache to cache query results if possible. Storage Layer - Stores the data in databases. Split into micropartitions for better reads. Supports structured and unstructured data. Data once loaded can only be accessed by SQL. What&rsquo;s a virtual warehouse? Compute resources for snowflake. It provides resources to run all the data loading / queries. There are standard warehouses and snowpark variants (for resource-intensive processes).
Streams &amp; Tasks # A stream can be linked to a DB and it will track all the changes that happen in the DB. A scheduled Task can once in a while pick up the list of changes in the stream, do any required transformations, and merge (like a merge query) into the target table to make it up to date.
Dynamic Tables # A new declarative way of defining transformation pipelines of data. It can pick up data from target tables and use a query definition to prepare a target table. It can auto-update based on the specified lag-time.
Usage # Snowflake has a dashboard UI to manage accounts, data warehouses, databases, etc. With it, you can create jupyter notebooks, worksheets (like notebooks but with SQL). You can also create dashboards (simple interactive UIs with parameterized queries) or streamlit webapps.
It also has a CLI, snowSql for querying data from a DB.
You can also connect to it using JDBC / ODBC drivers or native connectors (e.g., for python).
You can load data in batches or have continuous load of data (from Kafa for example).
Warehouse &amp; Lake ? # What are these things and how are they different from a DB? Well these are OLAP systems unlike DBs which are mostly OLTP. People use them to gather data from many sources and perform analytics on the large amount of data.
A warehouse typically has an ETL pipeline to load data into it after it has been processed. It mostly has structured data.
A lake typically stores the raw data, and may use the ELT methodology. It can store unstructured data in different forms.
`}),e.add({id:22,href:"/misc/web-auth/",title:"Web Authentication",section:"Fun Stuff",content:` Authentication in web services # How does an application figure out who is talking to it? What part of the identity of that person / system is enough?
e-mails &amp; passwords are one way. WebAuthn is another. kerberos is a good option inside an enterprise. it provides a convenient SSO experience when combined with SPNEGO. session tokens passed on as cookies can also work depending on the use case.
I&rsquo;m gonna look at some relatively modern ones. Note that unlike the above, these aren&rsquo;t cryptographic protocols. In the end they still use one of the above ways to authenticate the user at some point.
OIDC # OAuth 2.0 is the main thing. OIDC is just a standard way to do authentication with OAuth. Else ppl were making their own implementaitons.
OAuth 2.0 itself is an authorization protocol to provide one app (e.g., App A) access to a user&rsquo;s resources in another app (e.g., App B), after authenticating the user &amp; getting their consent via an authorization server. In the case of OIDC, the App A also gets an ID card of the user along with the access token of App B.
That ID card is sent as a JWT (JSON Web Token), which is a format. The authorization server could be App B itself, or another service that it trusts.
The flow is like this (one of many OAuth 2.0 &ldquo;flows&rdquo;. this one is the web server flow):
User wants to login to App A They click on a &ldquo;login with App B&rdquo; button on the App A App A redirects user to the authorization server for App B (the resource server) The authorization server checks whether the user has logged into App B, or if not, asks them to log in The authorization server checks whether the user provides their consent User is redirected to App A, which now has an authorization code App A asks for an access token &amp; ID token from authz server. this happens in App A&rsquo;s backend server. the access token will be used to talk to App B and it is supposed to be a SECRET! ID token is a JWT which is like an ID Card of the user. JWT is just encoded and not encrypted. it is signed though. App A now knows who the user is, as per the users records in App B&rsquo;s system App A can talk to App B via it&rsquo;s backend server, on behalf of the user, as per the scope of the access token Tech jargon:
client id &amp; client secret which App A (the client) uses to talk to the authorization server. doesn&rsquo;t involve the user callback URL / redirect URI, provided by App A. it is the URI that authorization server should redirect user to, if consent granted response type. what kinda response the client wants to get after authz server gets the user&rsquo;s consent authorization code. the default response type. this is a not-so-secret string that the App A will use for comms with the authorization server when talking about that particular user. it&rsquo;s like a session cookie. the authz server will only accept if it is accompanied with a client secret. JWT. the ID token of a particular user that authorization server sends to App A as a response when it sends the request along with the authorization code. registeration. when the client sets up an account with the authz server. it needs to give a redirect_uri &amp; some details. gets a client id, secret. if App A runs entirely on the client device, e.g., PWA / Mobile App, then they can&rsquo;t use the client secret, since it will be exposed to the user / public. in such cases, there&rsquo;s a PKCE flow which can be used.
there&rsquo;s also an Implicit flow for such devices, where instead of authz server sending an authorization code, it just sends the access token directly. however, this is a bit risky, since a secret is now on the client&rsquo;s device. it should be stored safely, e.g., via a httpOnly cookie.
there&rsquo;s a client credentials flow which doesn&rsquo;t involve the user at all, and used for system to system communication only.
there&rsquo;s a device flow for cases where user isn&rsquo;t able to interact on a device to provide their consent. e.g., a terminal.
in such cases, the device will ask user to open a link and type in a code to do the authorization grant with the authorization server.
OAuth 2.0 is a web standard. IETF RFC, whereas OAuth 1.0 was just a name used by some libraries floating around in the initial days before the standard got developed.
OIDC is not a web standard (maybe it needn&rsquo;t have been), but they have a standard written on their site : https://openid.net
JWT # JSON Web Token? With such a generic name, it&rsquo;s sure sounds like trouble. But it&rsquo;s also a web standard :O IETF RFC.
It consists of three parts. Once the JSONs of all three are encoded, it becomes a URL safe string, with a &lsquo;.&rsquo; separating the three parts. the parts are:
header. telling the subtype of token, algo used for signing etc. body. whatever JSON. all custom data, including secrets and stuff go here. the stuff here is also known as &ldquo;claim(s)&rdquo; signature. this is used to verify that the token was generated by the authorization service and not tampered with Once authenticated, the JWT is used to identify the client. Like a sessionID cookie. But unlike the cookie, the JWT has meaning when decoded &amp; can be decoded to get info about the user, e.g., username, email, permissions etc. Once the server sends the JWT to the client, the client can send it along with every request as part of the Authorization header. Because of the signature, the server knows the token isn&rsquo;t tampered with. It is also possible for the server to reject some JWTs after an expiration period, or expire them if they suspect a leak.
Some websites also use a concept of refresh token which allows the access token to be refreshed frequently to reduce impacts of leaks. A refresh token is has a longer expiry and can be used to refresh access tokens. What if a refresh token leaks? Yeah, it could. It should be stored in a safer place. And like access tokens, they can be invalidated.
JWTs became popular since they contain info about the user, that info can be used by the server for app logic instead of going to the DB to get info about the user who made the request. That also means that a JWT from one server can be sent to another related server and that needn&rsquo;t re-authenticate the user. Not really possible with sessionIds. However, this increases the request size if there&rsquo;s too much info being stored in the token.
Since it identifies a user, they should make sure to keep it secret. Should be treated at the same secrecy level as a password.
SAML # Is older than OAuth. Current version is SAML 2.0, but not actively being developed. Meant for SSO. It provides authentication and authorization.
Frequently used in internal enterprise systems. Uses a central IdP (identity provider) which all services talk to. Why would you ever use this? It&rsquo;s already used in multiple places. And the flow seems simpler than OAuth. However, OAuth is the preferred choice for new apps.
FAQs # These are questions that came up while I was exploring different posts / videos.
Why is a refresh token required if the access token itself could be used to get new ones? Uhh.. IDK. The claim is that a refresh token can be invalidated, but then so could access tokens.
Why provide a &ldquo;state&rdquo; param in the auth_code request? If you want to give the redirect_uri of your site some data about the state of the app from which the user was sent to the authz server. The other case is to prevent CSRF. Your site should be the able to determine if the state string indeed came from it. Else, someone could make a auth URL which will then ask the user to login, consent &amp; send them to your site.
more details: https://stackoverflow.com/q/26132066/13229013
What&rsquo;s the diff b/w state &amp; nonce? state is for browser based flows whereas nonce is for the id token request. to verify that the server is indeed returing a response to your request &amp; prevents replay attacks. state could have some meaning encoded whereas nonce is a random number. still don&rsquo;t get it fully. nonce can inform a user of MiTM attack, but it can&rsquo;t really prevent it I guess.
more details: https://stackoverflow.com/q/46844285/13229013
Why does redirect_uri need to be part of the access token request? This one is actually a topic of discussion. Some claim that it&rsquo;s not really useful. Apparently, not registerting a static redirect_uri can lead to phishing attacks if someone creates a link to make authz server send users to a rogue site. but that&rsquo;s only applicable for auth code requests. what about the access token request? which doesn&rsquo;t redirect. all this shouldn&rsquo;t happen when using the client secret.
more details: https://stackoverflow.com/questions/37659188/why-is-redirect-uri-required-on-access-token-request
`}),e.add({id:23,href:"/angular/forms/",title:"Forms",section:"Angular",content:` Forms and validation # There are two kinds of forms in Angular:
Template based (the content and the logic is in the HTML) Model based A.K.A. Reactive (the content and logic is in the component) Creating a form # You need the FormModule from &ldquo;@angular/forms&rdquo; to be imported in the module where you will be using forms. When you import that module, it adds an NgForm directive to all form tags. The directive instance can be accessed as described below. In the component with the form, on the form element, set a template reference variable like so: &lt;form #someNiceNameForForm=&quot;ngForm&quot;&gt;&lt;/form&gt;. This provides additional functionality as described in the docs. For each input element whose value you want, set the name attribute. This will be the key to access its value later on. For the submit action, prefer to bind to ngSubmit instead of using the submit button, like so: &lt;form #formTempVar=&quot;ngForm&quot; (ngSubmit)=&quot;handlerFunc(formTempVar.value)&quot;&gt;&lt;/form&gt; The value prop. on the temp-ref-var is an object where the value for each input field with a name attr. is available. You can also bind ngModel (which is a directive) on each input element to bind it to values on the component, like so: &lt;input (ngModel)=&quot;compoProp&quot; id=&quot;foo&quot; type=&quot;text&quot;&gt;. To achieve two way data binding you can do this: [(ngModel)]=&quot;compoProp. Validation # Angular turns off the default behaviour of adding the &ldquo;required&rdquo; attribute on input elements. It does provide its own validation features:
formTempRefVar has properties like valid, invalid, touched, dirty etc. So does each input element, under formTempRefVar.controls.inputElementName. Those properties for individual elements can also be accessed via temp-ref-vars like so: &lt;input type=&quot;text&quot; name=&quot;woah&quot; #niceHandle=&quot;ngModel&quot;&gt;{{niceHandle.valid}}&lt;/input&gt; Angular also adds classes like ng-valid, ng-touched, and ng-pristine to elements. It also sets ng-submitted on the form element when the form has been submitted. These can be used for styling The form can be reset by calling formTempRefVar.reset() The element&rsquo;s property under formTempRefVar.controls may not be defined initially, therefore, if you want to check if the element is in an invalid state you should do it like this: formTempRefVar.controls.inputElementName?.invalid Reactive forms # Here, the structure of the form and its validation rules are defined in the component itself. It&rsquo;s more flexible and lets you unit test things like validation easily. Here&rsquo;s how you make such a form:
You need the ReactiveFormModule like how template forms need FormModule The form is a property of the component. It is of the type FormGroup. You initialize it in ngOnInit, like so: let username = new FormControl(); let password = new FormControl(); let day = new FormControl(); let month = new FormControl(); let year = new FormControl(); let birthday = new FormGroup({ day: day, month: month, year: year }); this.userLoginForm = new FormGroup({ uname: username, paswd: password, dob: birthday }) The properties of the FormGroup are supposed to be the values you want from the form, or a group of values which are encased in a FormGroups of their own. You must bind the HTML form and input elements like so: &lt;form [formGroup]=&quot;userLoginForm&quot;&gt;&lt;/form&gt; and &lt;input formControlName=&quot;username&quot;&gt;&lt;/input&gt;. In case of grouped values, the group must be bound &lt;div formGroupName=&quot;dob&quot;&gt;&lt;/div&gt; and then the constituent elements like so: &lt;input formControlName=&quot;month&quot;&gt;&lt;/input&gt; You can also add a ngModelGroup attribute so that the form value will be structured so that the input elements within the group will be nested inside an object. A structure like this &lt;div ngModelGroup=&quot;lol&quot;&gt;&lt;input name=&quot;hi&quot;&gt;&lt;/div&gt; will give a value object like this: { // other fields lol: { hi: &#34;someval&#34; } } Validation (reactive form) # The format for a new FormControl is: new FormControl(value the field should have, validation for the field) where both params are optional An example validation, where you can mark a field as required is: FormControl(userName, Validators.required) where Validators must be imported from &ldquo;@angular/forms&rdquo; The state of the form is accessible from the primary FormGroup like so: this.userLoginForm.valid To use multiple validators, pass them as an array: [Validators.required, Validators.pattern('ab*')] The results of each validator (pass / fail) can be obtained like userLoginForm.controls.elementName.errors.whatEverValidation where the validation is something like required or pattern or something else. Custom validator # A validator is a function. It returns an error object if the validation failed else it returns null. The error object looks like this: {'errorName': errorValue}. The error value can then be accessed like elementName.errors.errorName. The only argument that the function takes is a FormControl object (which will be the element on which the validator is set).
Super custom validator # You can also use a directive as a validator. Since it is a class it needs to implement Validator from &lsquo;@angular/forms&rsquo; which means it needs to have a function validate that takes in a FormGroup (or FormControl depending on where the directive is used) and return null if there are no errors else an error object like before.
Since it is a directive it needs to be imported in the ngModule. To add it to Angular&rsquo;s list of validators (and therefore make it available for use) you can do this:
import { NG_VALIDATORS } from &#39;@angular/forms&#39; @Directive({ selector: &#39;wow-nice&#39; providers: [{ provides: NG_VALIDATORS, useExisting: NiceValidator, multi: true // this means add this validator as a provider to NG_VALIDATORS }] }) export class NiceValidator { validate(fg: FormGroup) { /* validation logic */} } Multi-field validation # You need to do a few weird things to validate multiple fields:
To access sibling fields, use the root group like so fg.root.controls.siblingElement To actually validate elements with the directive validator you need a temp-ref-var like so: &lt;div ngModelGroup=&quot;niceGrp&quot; validatorDirec #whyNeedIDK=&quot;ngModelGroup&quot;&gt;&lt;/div&gt; The sibling needs to re-run the validator whenever it updates. Can do that with an event binding: &lt;div (change)=&quot;whyNeedIDK.control.controls.someField.upDateValueAndValidity()&gt;&lt;/div&gt; This whole thing is just super complex and weird.
ngModel # TODO: this is one fancy thing. Check out the docs to understand it.
`}),e.add({id:24,href:"/angular/pipes/",title:"Pipes",section:"Angular",content:` Transforming data # Built-in pipes # You can transform data before it is rendered in a template. There are many inbuilt pipes. The format is {{ yourContent | pipeName:pipeArg1 }} where the arguments are JS objects / literals and are optional. Example: &lt;p&gt;A: {{a | currency:'CAD':'code'}}&lt;/p&gt;.
Custom pipe # An example pipe:
// in the file goodie.pipe.ts import {Pipe, PipeTransform} from &#39;@angular/core&#39; @Pipe({ name: &#39;goodiepipe&#39; // the name used to call the pipe in the template }) export class GoodiePipe implements PipeTransform { // this is the function that is called with the args transform(input: string, arg1: number) { if(arg1 &lt; 5) return input+&#34; is low&#34;; return input+&#34; is high&#34;; } } You must then add it to the declarations of the NgModule where you want to use it. It can then be used like so: {{ someVar | goodpipe:32 }}
Filter and Sort # AngularJS had the ability to do this with pipes. This meant that every time the data changed (i.e. a change detection cycle), the pipe would have to be called. This was slow.
Angular doesn&rsquo;t recommend that you sort or filter with pipes (you usually can&rsquo;t but there&rsquo;s the option to do it with impure pipes). It is recommended to sort / filter in the component itself.
Angular only runs a pipe when the identity of the data has changed. It&rsquo;s value. It does not check if the reference has changed. Therefore, if you change the properties of an object, Angular will not run the pipe for it.
Async # You can subscribe and process values from RxJS observables within the template itself. This is possible via the async pipe. It&rsquo;s often used with ngFor like this: &lt;div *ngFor=&quot;let book of books | async&quot;&gt;We have {{ book.name }}&lt;/div&gt; where books is an observable which has multiple next calls and a complete call.
When the component gets destroyed, it automatically unsubscribes from the observable. Every use of the async pipe is a new subscription. If the observable is from a http request, this might mean that the API calls happen multiple times. Eg.,
&lt;div *ngIf=&#34;books$ | async&#34;&gt; &lt;div *ngFor=&#34;let book of books$ | async&#34;&gt; We have {{ book.name }} &lt;/div&gt; &lt;/div&gt; This can be made better using the as keyword (which is actually an ngIf feature) like so:
&lt;div *ngIf=&#34;books$ | async as books&#34;&gt; &lt;div *ngFor=&#34;let book of books&#34;&gt; We have {{ book.name }} &lt;/div&gt; &lt;/div&gt; Purity # By default, pipes are pure. Pipes use data binding, Angular executes the pipe when a change is detected in the input value.
Pure pipes execute on pure changes (e.g. an object&rsquo;s reference itself changed or a primitive&rsquo;s value changed).
If a pipe is declared as impure, it will execute on all pure changes to the input as well as changes to the input object&rsquo;s properties. Since this can happen often, it is recommended to make impure pipes performant.
`}),e.add({id:25,href:"/angular/di/",title:"Dependency Injection",section:"Angular",content:` Adding features! ðŸ™Œ # Dependency injection # This is how you provide new components with extra resources they need to function. To indicate that a class (any class, not just a component / service) has a dependency or is a dependency you decorate it with @Injectable(). From the docs
The injector is the main mechanism. Angular creates an application-wide injector for you during the bootstrap process, and additional injectors as needed. You don&rsquo;t have to create injectors.
An injector creates dependencies, and maintains a container of dependency instances that it reuses if possible.
Some important points:
You declare dependencies of a class in its constructor For each dependency, you must have registered a provider with the injector. A provider creates the dependency object when required. (For a service, it can be the service class itself) Again, from the docs listed at the top of the page:
When Angular discovers that a component depends on a service, it first checks if the injector has any existing instances of that service. If a requested service instance doesn&rsquo;t yet exist, the injector makes one using the registered provider, and adds it to the injector before returning the service to Angular.
When all requested services have been resolved and returned, Angular can call the component&rsquo;s constructor with those services as arguments.
Register a provider # You can do it in three ways: In @Injectable() # You can specify the provider as the value to the providedIn key in the metadata object. If you specify 'root' one instance will be available to all components.
With an NgModule # You specify the providedIn property as the NgModule where you want this service to be available.
With a component # You can place it in the providers array in the metadata of a component and it will get its own instance of that service.
To use a function as a provider check out this example. It is preferred to provide the service in the root injector unless there&rsquo;s a requirement to make it available only in some ngmodule.
Using InjectToken # This is a way for the injector to find the required provider from the list of available providers. Its an alternative to using a string. Its better since the token is a variable and the compiler will complain if there is another variable with the same name.
Create a new token like this:
import { InjectionToken } from &#39;@angular/core&#39; let SOME_TOKEN = new InjectionToken&lt;retType&gt;(&#39;whatever description you want&#39;); // Its a convention to capitalize the token name // retType is the type of the object that this provider will create // &#34;any&#34; is a good option in case of a third-party object like jQuery Use it to register a new provider. The provide property will be set to SOME_TOKEN. The other prop. e.g. useValue contains the object that you want to provide e.g. jQuery&rsquo;s $.
The object can now be used via DI like so:
import { Inject } from &#39;@angular/core&#39; import { SOME_TOKEN } from &#39;./something.service&#39; constructor(@Inject(SOME_TOKEN) private jqSelector) {} ngOnInit() { this.jqSelector.doSomething() } useWhat # Alternatives to useValue
The usual way where you put the service class within the providers array of the ngModule is a shorthand for {provider: someGoodClass, useClass: someGoodClass} useExisting lets you use a different, already registered (i.e. existing), provider when the user requests one provider. Something like this: {provider: someGoodClass, useExisting: someShadyClass} useFactory lets you use a function to create an object. This is complex. Check out the docs. Injectors # Angular has three kinds of Injectors (and each have their hierarchies) which can be used when a dependency is requested:
ElementInjector (providing a dependency at a component level) EnvironmentInjector (the root injector is in this hierarchy) ModuleInjector (only for apps which use ngModule) The above is also the resolution order. If nothing works, it&rsquo;ll end up searching the NullInjector and throwing an error.
It is also possible to customize the default resolution algorithm with some decorators:
@Optional() will give a null value instead of throwing an error if a dependency is not found. @Self() will look into the current component&rsquo;s ElementInjector only In a eager-loaded app, all the providers of all modules are available throughout the app. (Whatt??? Don&rsquo;t worry, this only happens for providedIn: &lsquo;any&rsquo;)
For lazy-loaded modules, there is a new injector created for each loaded module which is then added to the injector hierarchy.
`}),e.add({id:26,href:"/angular/rxjs/",title:"RxJS",section:"Angular",content:` Async &amp; network stuff # Not everything happens right at once in a webapp. It shouldn&rsquo;t wait for certain events when it can execute other things. This is where asynchronous processing is useful. Promises were the preferred way to do it but now there are observables (from rxjs). Promises represent one event that happens in the future while observables represent zero or more events that could happen synchronously or in the future. This particular section is about RxJS and HTTP in Angular.
The docs tells how observables could be used in place of promises.
Good resources for RxJS:
A gist that explains reactive programming A single page crash course giving an overview of RxJS Overview of main concepts. Official docs Video showing off some RxJS stuff live Video about RxJS stuff specific to Angular HTTP # To communicate via HTTP in JS first import HttpClientModule from &ldquo;@angular/common/http&rdquo; into the ngModule of your choice. Wherever required, a dependency of type HttpClient from &ldquo;@angular/common/http&rdquo; can be injected so that HTTP calls can be made with it.
Once you have an object of HttpClient, say http, you can perform calls such as: http.get&lt;T&gt;(url) where T is the type of the response you expect. The result is an Observable&lt;T&gt; which can be subscribed to.
To add query parameters just do string concatenation :). E.g. http.get&lt;T&gt;(url+&quot;?userid=&quot;+searchUserId) ðŸŒ´
There&rsquo;s also the delete method and post method. The post method needs a few more args like so: http.post&lt;T&gt;(url, body, options). Where body is an object containing the data you want to give and options is also an object which has properties like HTTP headers.
The observables that the HTTP methods return just pass one value and then complete.
RxJS ðŸ’§ # Helps in managing events in a functional programming and asynchronous manner. Its main concepts are:
Observables # An observable is a stream of lazy push-based computations. They can deliver values (zero to infinite) synchronously or asynchronously. Create one like this:
import { Observable } from &#39;rxjs&#39;; const obsv = new Observable(subscriber =&gt; { // a stream of nexts optionally followed by either an error or a complete // e.g. : subscriber.next(anyValue1); subscriber.next(anyValue2); subscriber.next(anyValue3); subscriber.next(anyValue4); // only one of the following two should be there subscriber.error(anyError); subscriber.complete(); }); The observable can then be subscribed to like so:
const subc = obsv.subscribe(value =&gt; { console.log(value); }) The observable can also be stopped like so:
subc.unsubscribe(); // the behaviour of the function can be customized // by setting the return value of the subscription function const custom = new Observable(subscriber =&gt; { // do some computation return function unsubscribe() { // do clean up perhaps? } }); Observables can be used in HTML templates. As a convention append a &ldquo;$&rdquo; while naming an observable so that it is distinguishable in the template.
There can be multiple subscribers. Each one will get the same stream of data. An observable may complete before some async operations within it have run. All subscribers will receive same series of next, error and complete events as each other. When one of them unsubscribes, it stops the flow of data to only that one. Observer # A consumer of an observable. Its just an object like this:
const observer = { next: value =&gt; console.log(&#39;Got a value: &#39; + value), error: err =&gt; console.log(&#39;Finished with an error: &#39; + err), complete: () =&gt; console.log(&#39;Finished peacefully&#39;); }; const subc = obsv.subscribe(observer); Some or all properties can be ignored
Subscriptions # They are the objects returned on subscribing to an observable. They essentially have only 3 methods:
unsubscribe(): stop receiving data from the observable add(otherSubscription): so that unsubscribing this subscription will unsubscribe the other one too remove(otherSubscription): to undo the add method described above Operators # Easy to use resource to figure out what kind of operator you need.
They transform the data produced by observables. They are functions. There are two kinds: Creation # They generate observables from some kind of data / instruction. These functions return observables. An example is of from &lsquo;rxjs&rsquo;. It takes in one or more arguments and then creates an observable that pushes these objects one after the other.
Pipeable # They generate observables from other observables. These functions return functions that take in an observable and return an observable. An example is map from &lsquo;rxjs/operators&rsquo;. You use it like let funk = map(x =&gt; x+x) and then outputObsv = funk(inputObsv).
The official docs has a useful list of commonly used observables, grouped by category.
Many times multiple pipeable operators are used in sequence. It becomes messy, thus we have the pipe function which can be used like this:
const obsv = of(1, 2, 3); const obsv1 = map(x =&gt; x * x)(obsv); const obsv2 = filter(y =&gt; y &gt; 3)(obsv1); obsv2.subscribe(v =&gt; console.log(v)); // is equivalent to const subscrip = of(1, 2, 3).pipe( map(x =&gt; x * x), filter(y =&gt; y &gt; 3) ).subscribe( v =&gt; console.log(v) ); Subjects # An observerable that can also be used as an observer. They can be used to make an observable multicast (They are unicast by default). Using it as an observable:
import { Subject } from &#39;rxjs&#39;; const obsv = new Subject&lt;any&gt;(); // the default type is void obsv.subscribe(/* an observer */); obsv.next(someVal1); obsv.next(someVal2); obsv.complete(); It can also be used as an observer. Just pass the Subject object to an observer&rsquo;s subscribe method. This works since the Subject already has next, error, and complete methods.
The important difference between a subject and a normal observable is that a subject does not maintain separate execution contexts. A normal observer creates an independent execution context for each observer it has. Whenever an observer subscribes to a subject it can receive values from there on only. Not the old values. There are specialized subscribers that can buffer some old values to give new observers. A cool trick is to make an observable multicast with a subject. Like so:
import { of, Subject } from &#39;rxjs&#39; const obsv = of([1, 2, 3, 4, 5]); const sub = new Subject&lt;number&gt;(); const scp1 = sub.subscribe(e =&gt; console.log(e)); const scp2 = sub.subscribe(e =&gt; console.log(e)); obsv.subscribe(sub); Some useful specialized subjects:
BehaviourSubject # Holds the current value that was pushed. When new observers subscribe, they immediately get that value. Afterwards they continue to get pushed values like other old observers.
ReplaySubject # A generalized form of BehaviourSubject. It can hold a buffer of n previously pushed values and pass them at once to new observers. They are used like this: const sub = new ReplaySubject&lt;number&gt;(bufferSize, expirationTimeForEachValue [optional])
Void Subject # This is the default type of subject created when no type is specified. The subscriber for this doesn&rsquo;t receive any values for its next function. It&rsquo;s useful when you just want to know that some event occured.
Scheduler # Controls when subscriptions start. Can modify this so that subscriptions start immediately, on the next event loop, next micro loop, or after some timeout. This is kinda complex so here&rsquo;s a link to the docs.
RxJS operators # Another section for this topic?? Yep, there&rsquo;s a lot of variety here and these are the popular ones:
Bunch of useful ones grouped by category: https://www.learnrxjs.io/learn-rxjs/operators
Higher-order observable transformers # Convert higher order observables into regular ones i.e., Observable&lt;Observable&lt;T&gt;&gt; to Observable&lt;T&gt;. Nested subscriptions are not recommended since it is harder to unsubscribe and easier to cause timing issues. All the below transformers take an argument of a function returning an observable. Thus, there are two observables here. An &ldquo;outer&rdquo; one and an &ldquo;inner&rdquo; one. For all of them, the final returned observable will go to error state if either inner or outer go to error.
concatMap: For each emitted value of outer observable, get all emmitted values of inner observable till completion, and then proceed to next emitted value of outer and repeat the same. mergeMap: Goes through emissions of outer observable and starts the inner observable for each one, but all the inner observable emit in parallel and the values that appear finally depends on their times of emissions. switchMap: For each emitted value of outer observable, cancel any previous subscribtions of inner observable and start new subscription. Example:
function getInnerObs(x: number): Observable&lt;string&gt; { // does some operations } const outerObs = interval(1000).pipe(take(5)); outerObs.pipe( xMap(outerVal =&gt; getInnerObs(outerVal)) ).subscribe( // observer logic ) What about flatMap ? That&rsquo;s just a deprecated alias for mergeMap. Multicast # Assume an observable o1. When it is subscribed in two places, the subscriber logic of the observable runs twice. If it&rsquo;s an observable got from http, that would mean it would make the API call twice. This may not be expected. Especially in situations where the subscription is implicit e.g., async pipe and / or the subscriber logic is expensive.
Generally, this is avoided by creating a subject which takes value from the observable and there are multiple subscriptions to that subject.
However, that is not required. It can also be done with a shareReplay(n) operator. Where n is number of emissions to give to new subscriptions.
Example:
mainObs = new Observable&lt;number&gt;((subscriber) =&gt; { let total = 0; for(let i=0; i&lt;100; i++) { total += i; } subscriber.next(total); }); sideObs = this.mainObs.pipe( tap(val =&gt; console.log(&#39;before shareReplay&#39;, val)), shareReplay(1), tap(() =&gt; console.log(&#39;after shareReplay&#39;)) ); user1 = this.sideObs; user2 = this.sideObs.pipe( map(val =&gt; val*-2) ); There is also the share() operator, but that will not give values to late subscriber. E.g., user2 will not get a value
mainObs = new Observable&lt;number&gt;((subscriber) =&gt; { let total = 0; for(let i=0; i&lt;100; i++) { total += i; } subscriber.next(total); }); sideObs = this.mainObs.pipe( tap(val =&gt; console.log(&#39;before shareReplay&#39;, val)), share(), tap(() =&gt; console.log(&#39;after shareReplay&#39;)) ); user1 = this.sideObs; user2!: Observable&lt;number&gt;; constructor() { setTimeout(() =&gt; { this.user2 = this.sideObs.pipe( map(val =&gt; val*-2) ); }, 1000); } Error handling # Whenever there is a an error thrown in the subscriber logic of the observable, or somewhere in the pipeline, rxjs catches automatically it to emit an error notification to the observers. E.g.,
export class SubComponent { notifs: {t:string, val:any}[] = []; obs = new Observable&lt;number&gt;(subscriber =&gt; { subscriber.next(1); throw new Error(&#39;custom err&#39;); // if we comment this out, the error would be thrown later on in the pipeline subscriber.next(2); subscriber.next(3); subscriber.next(4); }).pipe( map(val =&gt; { if (val &lt; 3) { return val; } throw new Error(&#39;val gte 3&#39;) }) ).subscribe({ next: (val) =&gt; this.notifs.push({t: &#39;next&#39;, val}), error: (val) =&gt; this.notifs.push({t: &#39;error&#39;, val}), complete: () =&gt; this.notifs.push({t: &#39;complete&#39;, val: &#39;dunzo&#39;}) }) } An error state is a terminal state for an observable. There won&rsquo;t be any emissions after that.
It is possible to catch errors and return some value instead. This is through the catchError operator. The argument to the operator is a function which returns a replacement observable.
catchError will only catch errors which happen above it in the pipeline or in the subscriber logic. In the example above, a catchError could be added after the map like so:
catchError((err) =&gt; { console.log(&#39;got an error&#39;, err); return new Observable(sub =&gt; { /* any logic*/ }); }) There are some frequently used observables for this case:
EMPTY. completes immediately without emitting any value throwError(fnWhichReturnsAnError). emits an error notification immediately. The error object is as per the function passed to this operator. What if the observer doesn&rsquo;t specify a function for the error notification? If it just has a next handler, then the error is thrown up the call stack, and in the case of a browser, will end up in a console.error.
`}),e.add({id:27,href:"/angular/test/",title:"Testing",section:"Angular",content:` Unit &amp; Integrated tests # NOTE : Check the reference doc regarding Testing APIs for Angular .
Angular uses Jasmine for unit testing and Karma to run the tests on browsers. Tests can be:
Isolated # Only tests the JS class not the component Mostly used for services and pipes Need to create instances of classes on your own Integrated # Tests the class and template together Mostly used for components and directives The objects are created by the framework Unit tests # They test a single unit (like a class, function, or a bunch of classes) in isolation. Some features of unit tests:
Fast (to code and to execute) Should handle one state change at max Assert one thing Minimal dependencies They follow a structure of:
Assemble - The setup code for the test Action - The thing that the user will likely do. Can be a state change Assert - &ldquo;Is the result what is expected?&rdquo; Run unit tests with ng test which asks Karma to look for *.spec.ts files and execute the tests within them. A basic test looks like this:
describe(&#39;a nice test&#39;, () =&gt; { // do something beforeEach(() =&gt; { // code to run before each &#39;it&#39; }) it(&#39;exact test stuff&#39;, () =&gt; { // do something expected(valA).toBe(&#39;good stuff&#39;); }) }) toBe is just one of the many &ldquo;matchers&rdquo; jasmine has. The official docs has a list of matchers Mocking # To minimize depedencies on external code they are mocked for things like network calls, DB use, side effects etc. E.g. instead of making HTTP requests with the http dependency use a mock http dependency that simulates network calls and returns results immediately.
Mock with jasmine like this: const mockStuff jasmine.createSpyObj('some desc', ['method1', 'method2', 'method3']). A particular method can be modified to return a particular value like this: mockStuff.method1.and.returnValue(anyValue) To check if a method is being called in the function with particular params, use: expect(mockStuff.method2).toHaveBeenCalledWith(param1, param2) where the parameters can be exact values or it can just check that the types match by passing in an arg like jasmine.any(ClassName) Components can be tested just like services for isolated tests. Instantiate the class with mock dependencies, set any input params and then test whatever methods needed to be tested. Integrated tests # They&rsquo;re more complex and are meant to test an entire functionality. It can test the template and the component in an environment that&rsquo;s a close approximation to real world usage.
Setup # This is more complex since Angular creates the instances of the component and template and places them in a module. This setup goes in a beforeEach. The code for this is usually generated by the cli when using ng g c and is placed in &ldquo;*.component.spec.ts&rdquo;. It looks like this:
// inside a describe callback let component: NiceComponent; // the type let fixture: ComponentFixture&lt;NiceComponent&gt;; // from &#34;@angular/core/testing&#34; let debugEl: DebugElement; // handle to the template let rawHTML: HTMLElement; // handle to the raw html of the template let mockThatService; // mock object for a dependency beforeEach(() =&gt; { // if you don&#39;t want complex functionality no need to use a spyObj // a simple object with the props required will do mockThatService = {}; // creates the module where the component will run TestBed.configureTestingModule({ declarations: [ component ], providers: [ { provide: ThatService, useValue: mockThatService } ] }); fixture = TestBed.createComponent(NiceComponent); component = TestBed.componentInstance; debugEl = TestBed.debugElement; rawHTML = TestBed.nativeElement; // runs change detection so the template is kept updated with the component fixture.detectChanges(); }) Deep &amp; Shallow tests # A shallow integration test just includes the component that is being tested while a deep test will also include the necessary children component (but may not test them). A deep test is heavy because of dependencies but it is complete.
When using a shallow test, it is possible to ignore the errors caused by dependencies on other components. This is done by adding a schema to the testing module like so:
TestBed.configureTestingModule({ declarations: [/* wtv */], providers: [/* wtv */], schemas: [ NO_ERRORS_SCHEMA // from angular core ] }) Debugging # This can be a pain. Here are some tools to help:
Augury can present info neatly in dev tools. ngx-logger is a nice logger apparently. Put debugger in your TS code so it can be paused in the browser. `}),e.add({id:28,href:"/angular/libraries/",title:"Libraries",section:"Angular",content:` Ultra level reusability # They provide extra functionality to Angular. They don&rsquo;t run on their own. They need to be used in an application. There are many first party libraries that are regularly used, like &ldquo;@angular/forms&rdquo;.
Angular libraries (e.g. the @angular/x ones) are NgModules.
Some functionality of an app can be packaged into a library so it can be reused with other apps. They can then be published in &ldquo;npm&rdquo; or wherever.
Installing them # Install via npm like so: npm i jquery. If the library does not contain typings for typescript within in a .d.ts file you can try to get them via npm i @types/jquery. It can then be use like so: import * as $ from jquery
You can also define types on your own via a .d.ts file e.g. cooltypes.d.ts in src/ where you delcare interfaces and functions.
An alternate way to use them is to put them in the global scope as if they were put in a script tag. That&rsquo;s done by adding the source to the scripts array in angular.json
Creating one # It&rsquo;s a convention to prefix library names with ngx- to denote they are Angular libs.
`}),e.add({id:29,href:"/angular/signals/",title:"Reactivity with Signals",section:"Angular",content:` Signals # Apparently, it is used to make Angular apps more responsive and improve Change Detection.
Signals can be thought of as a combination of state and a notification mechanism for changes to that state.
How is that different from RxJS observables? Observables are a notification mechanism for events and don&rsquo;t really hold state.
What about Subjects then?? Well, they are similar, but state management code is simpler with signals (based on trials).
One such benefit is that there is no need to manually &ldquo;complete&rdquo; &amp; &ldquo;unsubscribe&rdquo;.
Sometimes, rxjs pipelines may be better use, given that they will process every single emission. Unlike a computed with signals.
RxJS is still the choice when the domain has asynchronous activites, e.g., fetching data over a network.
This is a good course : RxJS and Angular Signals Fundamentals
Simple uses # They can be created in the component like so: const newSig = signal&lt;TypeOrLetItBeInferred&gt;(defaultValue). The default value is a must.
They can be read anywhere in the TS code like so: newSig(). Same thing in the template file. When a signal is used in a template, Angular registers it as a dependency of the template and, whenver required, will re-render the portion of the template where the signal is used.
To update values, just do newSig.set(newVal) and it will set the value and notify dependents. Similary, there is a newSig.update((oldVal) =&gt; { /* code to return new value based on old value */ }) to set the value and notify dependents.
Effects # When a signal&rsquo;s value changes, there is a delay till the next change detection cycle for the updates to be visible in the template.
One dependent of a signal is a computed signal. It&rsquo;s a readonly signal whose value is derived from other signals.
It&rsquo;s defined like this const compSig = computed(() =&gt; { /* may use some signals to return the value */ }). All the signals used in the function block become the dependencies.
It will only do the computation if the value of the computed signal is read anywhere, and it won&rsquo;t do the computation again if none of the dependencies have changed. Memoization basically.
Computed signals are lazily evaluated also.
Another dependent is an effect which schedules an execution of the arrow function whenever dependencies change. E.g., effect(() =&gt; { /**/ }) Unlike a computed, it will at least run once. (because there is no concept of &ldquo;reading&rdquo; an effect. it is only for side-effects) If there are multiple dependency updates, it is possible that only one execution is scheduled for all those updates.
The effect actually returns a &ldquo;ref&rdquo; which can be used to cancel any queued scheduled executions for that effect.
In both above cases, it&rsquo;s not recommended to update any dependency / dependents inside the function block as it can cause circular executions.
An effect can be setup only in an &ldquo;injection context&rdquo; such as constructor etc. or you can pass it an injector reference.
More about that here https://github.com/angular/angular/issues/56357
Angular itself mentions that effects are not likely to be found in most applications and that computeds are generally better.
Notifications # A signal will not notify the dependents if the &ldquo;value&rdquo; of the signal is the same as it was before, even if someone had .set or .update the signal.
How does it know value has changed? Object reference. That&rsquo;s why if your signal is holding an array, you should update the array reference itself when performing updates.
E.g., sig.update(currentArr =&gt; [...currentArr, {val: 'newVal'}]) instead of getting array ref from signal and pushing to that array.
You should always use .set or .update to inform about a value update, but even with that, there are problems for arrays due to obj ref if you do sig.update(cArr =&gt; cArr.push({val: 'newVal'})). That&rsquo;s why the above method is better.
Alternatively, can we define a signal&rsquo;s equality checker to solve this problem?
uniqSig = signal([5, &#39;hi&#39;], { equal: (prev, cur) =&gt; { if (prev.length !== cur.length) { return false; } return prev.every((pval, i) =&gt; pval === cur[i]); } }); Not in this case. Since we are modifying the array that signal is holding, prev and cur will always be the same.
Computed / Effect signals will only track signals within the enclosing function which were read during the last execution.
At every execution, they update the list of dependencies.
Error handling # Signals are a store for values. They don&rsquo;t emit error events. They just store a value. However, if there is an error thrown in a computed signal, the error will be propagated till the place where the computed signal&rsquo;s value is read. Whether that is TS code or in the template. If the error is in the template, it can also cause problems with displaying any other signals which are the dependencies of the computed signal. dependents will anyways error out.
Fine grained reactivity # All resources mention that signals improve change detection and provide &ldquo;fine grained reactivity&rdquo; compared to observables. But what exactly is the difference?
&lt;form class=form-1&gt; &lt;label class=input-field-holder&gt; &lt;p&gt;Box is {{ /* signal or observable | async */ }}&lt;/p&gt; &lt;input type=text / [(ngModel)]=&#34;someText&#34;&gt; &lt;/label&gt; &lt;div&gt; {{ someData }} &lt;/div&gt; &lt;/form&gt; &lt;div class=data-block&gt; &lt;ul&gt; &lt;li *ngFor=&#34;let data of datalist; i = index&#34;&gt; Data for {{i}} is {{data}}.&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; If the signal&rsquo;s value changes and the notification is sent to the change detector, it will only check the &lt;p&gt; tag.
If an observable is used, it would trigger change-detection for the entire component. Requiring all bindings to be evaluated again.
Use with RxJS # RxJS used to be the only way to handle reactivity. Now signals can share that responsibility.
RxJS is still recommended for asynchronous ops, data fetching and transformations in the service layer. Also for event management. Signals are the recommended ones for components. why? &ldquo;improved change detection&rdquo; apparently. They also make state management easier to read. In services and components.
Also, rxjs makes sure observers get every single event which comes from an observable.
Not the case with signals. Effects or computed might only get some values if many values are sent before the effect / computed logic gets a chance to be scheduled to run. Once they get a chance to run, it is guaranteed that they will get the last value of the dependency signal.
There is an rxjs-interop library under the Angular monorepo which helps to convert between rxjs primitives and signals.
Observable to Signal # Use the toSignal(observable, options) function. The optional parameter can help specify an initial value if there is one. E.g., {initialValue: 123}. It creates a read-only signal and subscribes to the observable.
Signal to Observable # If you want to use the signal&rsquo;s value in an existing rxjs pipeline, it can be useful to convert the signal to an observable with toObservable(signalName).
However, the resultant observable will not emit all values which the signal contains. This function works by using an effect() so the observable may end up emitting some of the values similar to how effect() works.
It might be something like this:
makeObs&lt;T&gt;(signal: Signal&lt;T&gt;): Observable&lt;T&gt; { const tempSubject = new Subject&lt;T&gt;(); effect((onclean) =&gt; { try { tempSubject.next(signal()); } catch(e) { tempSubject.error(e); } onclean(() =&gt; tempSubject.complete()); }); return tempSubject.asObservable(); } A possible problem to watch out is that once an observable emits an error, it will close and won&rsquo;t emit values.
`}),e.add({id:30,href:"/tmp/",title:"/tmp",section:"Introduction",content:` Temporary code access # Random stuff that doesn&rsquo;t fit anywhere else.
`}),e.add({id:31,href:"/whatnext/",title:"/next",section:"Introduction",content:` So much to learn # These sound useful:
WebDev stuff # Search for &ldquo;TODO&rdquo; in notes and do those parts Angular router - https://blog.angular-university.io/angular2-router/ What really is ngModule - https://blog.angular-university.io/angular2-ngmodule/ How do service workers work? Service Workies Good article on testing. This covers TDD and stuff Java # jvm section modules section web server section spring boot section - there&rsquo;s a LOT here SRE principles # I would like to ensure that systems run reliabily and handle errors gracefully.
Google - Site Reliability Engineering Google - Site Reliability Engineering Google - Site Reliability Engineering Communication # Getting better at communication
Guide to Internal Communication, the Basecamp Way Effective communication is not about what you say Writing documentation. It&rsquo;s useful because that&rsquo;s what people see first and that&rsquo;s how they can contribute and use what you&rsquo;re building. Some points from here and this place which shows you how to start. There are also principles to follow. Low Priority - Design # Get an overview of what design is about from this talk. Learn how to use penpot with their YT tutorials. This walkthrough can give a good idea. Note down points from Brad&rsquo;s Walkthroughs and also Kevin&rsquo;s. `}),e.add({id:32,href:"/credits/",title:"/credits",section:"Introduction",content:` Credits # Built with HUGO Uses the hugo-book theme Compass icon by Icons8 You can find the source for this site on GitHub.
A small guide to shortcodes within this theme:
Theme Guide `}),e.add({id:33,href:"/shortcodes/",title:"theme-guide",section:"Introduction",content:` Buttons # Buttons are styled links that can lead to local page or external link.
Example # {{&lt; button relref=&#34;/&#34; [class=&#34;...&#34;] &gt;}}Get Home{{&lt; /button &gt;}} {{&lt; button href=&#34;https://github.com/alex-shpak/hugo-book&#34; &gt;}}Contribute{{&lt; /button &gt;}} Get Home Contribute Columns # Columns help organize shorter pieces of content horizontally for readability.
{{&lt; columns &gt;}} &lt;!-- begin columns block --&gt; # Left Content Lorem markdownum insigne... &lt;---&gt; &lt;!-- magic separator, between columns --&gt; # Mid Content Lorem markdownum insigne... &lt;---&gt; &lt;!-- magic separator, between columns --&gt; # Right Content Lorem markdownum insigne... {{&lt; /columns &gt;}} Example # Left Content # Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.
Mid Content # Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!
Right Content # Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.
Details # Details shortcode is a helper for details html5 element. It is going to replace expand shortcode.
Example # {{&lt; details &#34;Title&#34; [open] &gt;}} ## Markdown content Lorem markdownum insigne... {{&lt; /details &gt;}} {{&lt; details title=&#34;Title&#34; open=true &gt;}} ## Markdown content Lorem markdownum insigne... {{&lt; /details &gt;}} Title Markdown content # Lorem markdownum insigne&hellip;
Hints # Hint shortcode can be used as hint/alerts/notification block.
There are 3 colors to choose: info, warning and danger.
{{&lt; hint [info|warning|danger] &gt;}} **Markdown content** Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa {{&lt; /hint &gt;}} Example # Markdown content
Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa Markdown content
Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa Markdown content
Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa Tabs # Tabs let you organize content by context, for example installation instructions for each supported platform.
{{&lt; tabs &#34;uniqueid&#34; &gt;}} {{&lt; tab &#34;MacOS&#34; &gt;}} # MacOS Content {{&lt; /tab &gt;}} {{&lt; tab &#34;Linux&#34; &gt;}} # Linux Content {{&lt; /tab &gt;}} {{&lt; tab &#34;Windows&#34; &gt;}} # Windows Content {{&lt; /tab &gt;}} {{&lt; /tabs &gt;}} Example # MacOS MacOS # This is tab MacOS content.
Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.
Linux Linux # This is tab Linux content.
Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.
Windows Windows # This is tab Windows content.
Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.
`})})()