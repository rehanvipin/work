---
weight: 6
title: "Web Authentication"
# bookFlatSection: true
# bookToc: false
bookCollapseSection: false
---
# Authentication in web services
How does an application figure out who is talking to it? What part of the identity of that person / system is enough?

e-mails & passwords are one way. WebAuthn is another.
kerberos is a good option inside an enterprise. it provides a convenient SSO experience when combined with SPNEGO.
session tokens passed on as cookies can also work depending on the use case.

I'm gonna look at some relatively modern ones:
* SAML
* OAUTH 2
* OIDC
* JWT ??

## OIDC
OIDC is an authentication mechanism built on top of OAuth 2.0.  
OAuth 2.0 itself is an authorization protocol to provide one app (e.g., App A) access to a user's resources in another app (e.g., App B), after authenticating the user & getting their consent via an authorization server.
In the case of OIDC, the App A also gets an ID card of the user along with the access token of App B.  
That ID card is sent as a JWT (JSON Web Token), which is a format.
The authorization server could be App B itself, or another service that it trusts.

The flow is like this (one of many OAuth 2.0 "flows". this one is the web server flow):
* User wants to login to App A
* They click on a "login with App B" button on the App A
* App A redirects user to the resource server to get an access token for App B
* The resource server checks whether the user has logged into App B, or if not, logs them in
* The resource server checks whether the user provides their consent
* User is redirected to App A, which now has an authorization code
* App A asks for an access token & ID token from authz server. this happens in App A's backend server. the access token will be used to talk to App B.
ID token is a JWT which is like an ID Card of the user. JWT is just encoded and not encrypted. it is signed though. and it is supposed to be a SECRET!
* App A now knows who the user is, as per the users records in App B's system, and as much as it has scope to see
* If App A wants, it can talk to App B on behalf of the user, as per the scope of the access token

Tech jargon:
* client id & client secret which App A (the client) uses to talk to the authorization server. doesn't involve the user
* callback URL, provided by App A. it is the URI that resource server should send user to, if consent granted
* response type. what kinda response the client wants to get after authz server gets the user's consent
* authorization code. the default response type. this is a secret that the App A will use for comms
with the authorization server when talking about that particular user. it's like a session cookie.
* JWT. the ID token of a particular user that authorization server sends to App A
as a response when it sends the request along with the authorization code.

if App A runs entirely on the client device, e.g., PWA / Mobile App, then they can't use the client secret, since it will be exposed to the user / public.
in such cases, there's a PKCE flow which can be used.

OAuth 2.0 is a web standard. [IETF RFC](https://www.rfc-editor.org/info/rfc6749), whereas OAuth 1.0 was just a name used by some libraries floating around in the initial days before the standard got developed.

## JWT
JSON Web Token? With such a generic name, it's sure sounds like trouble. But it's also a web standard :O [IETF RFC](https://datatracker.ietf.org/doc/html/rfc7519).

It consists of three parts. Once the JSONs of all three are encoded, it becomes a URL safe string, with a '.' separating the three parts. the parts are:
* header. telling the subtype of token, algo used for signing etc.
* body. whatever JSON. all custom data, including secrets and stuff go here. the stuff here is also known as "claim(s)"
* signature. this is used to verify that the token was generated by the authorization service and not tampered with

Once authenticated, the JWT is used to identify the client. Like a sessionID cookie. But unlike the cookie, the JWT has meaning when decoded & can be decoded
to get info about the user, e.g., username, email, permissions etc. Once the server sends the JWT to the client, the client can send it along with every request
as part of the Authorization header. Because of the signature, the server knows the token isn't tampered with. It is also possible for the server to reject some
JWTs after an expiration period, or expire them if they suspect a leak.

Some websites also use a concept of _refresh token_ which allows the access token to be refreshed frequently to reduce impacts of leaks.
A refresh token is has a longer expiry and can be used to refresh access tokens. What if a refresh token leaks? Yeah, it could.
It should be stored in a safer place. And like access tokens, they can be invalidated.

Why they became popular is that since it contains info about the user,
that info can be used by the server for app logic instead of going to the DB to get info about the user who made the request.
That also means that a JWT from one server can be sent to another related server and that needn't re-authenticate the user. Not really possible with sessionIds.
However, this increases the request size if there's too much info being stored in the token.

Since it identifies a user, they should make sure to keep it secret. Should be treated at the same secrecy level as a password.

## SAML
Is older than OAuth. Current version is SAML 2.0, but not actively being developed. Meant for SSO. It provides authentication and authorization.  
Frequently used in internal enterprise systems. Uses a central IdP (identity provider) which all services talk to.
Why would you ever use this? It's already used in multiple places. And the flow seems simpler than OAuth. However, OAuth is the preferred choice for new apps.